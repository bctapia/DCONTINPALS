      SUBROUTINE CONTINPALSMAINPROGRAM
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  CONTIN.  MAIN SUBPROGRAM.
C  FOR THE REGULARIZED SOLUTION OF LINEAR ALGEBRAIC AND
C      LINEAR FREDHOLM INTEGRAL EQUATIONS OF THE FIRST KIND, WITH
C      OPTIONS FOR PEAK CONSTRAINTS AND LINEAR EQUALITY AND INEQUALITY
C      CONSTRAINTS.
C  REFERENCES - S.W. PROVENCHER (1982) COMPUT. PHYS. COMMUN., VOL. 27,
C                                      PAGES 213-227, 229-242.
C                               (1982) CONTIN USERS MANUAL (EMBL
C                                      TECHNICAL REPORT DA05).
C  AS A NEW USER YOU SHOULD NOTIFY -
C        S.W. PROVENCHER
C        EMBL (EUROPEAN MOLECULAR BIOLOGY LABORATORY)
C        POSTFACH 504209
C        D-6900 HEIDELBERG
C        FEDERAL REPUBLIC OF GERMANY
C      SO THAT YOU CAN OBTAIN THE USERS MANUAL (WHICH IS ESSENTIAL)
C      AND HAVE YOUR NAME PUT ON A MAILING LIST FOR UPDATES, ETC.
C----------------------------------------------------------------------
C THIS VERSION OF CONTIN HAS BEEN MODIFIED TO SOLVE FREDHOLM INTEGRAL
C EQUATIONS WITH CONVOLUTED EXPONENTIALS AS KERNELS OF THE TYPE THAT
C OCCUR IN THE ANALYSIS OF POSITRON ANNIHILATION LIFETIME DATA.
C  REFERENCES : R.B. GREGORY AND Y. ZHU, NUCL. INSTR. METH. PHYS. RES.
C                                       A290, 172-182 (1990).
C              R.W. WIJNAENDTS VAN RESANDT, R.H. VOGEL
C              AND S.W. PROVENCHER, REV. SCI. INSTR. 53, 1392 (1982)
C
C THE METHOD AVOIDS DIRECT DETERMINATION OF THE RESOLUTION FUNCTION
C BY EMPLOYING THE DECAY CURVE OF A REFERENCE MATERIAL WITH A WELL-
C KNOWN SINGLE LIFETIME. THE PROGRAM INCLUDES CORRECTIONS FOR SOURCE
C COMPONENTS IN THE REFERENCE AND SAMPLE DECAY CURVE AND FOR
C ZERO-TIME SHIFTS BETWEEN COLLECTION OF THE SAMPLE AND REFERENCE DATA
C
C THE ORIGINAL USER SUBPROGRAMS HAVE BEEN EXTENSIVELY MODIFIED.
C IN ADDITION, THE SUBROUTINE READYT HAS BEEN MODIFIED TO READ THE
C THE REFERENCE DATA (ALWAYS REQUIRED).
C
C IF ANY DIFFICULTIES ARISE IN THE USE OF THIS MODIFIED VERSION OF
C CONTIN PLEASE CONTACT:  R.B. GREGORY
C                         DEPARTMENT OF CHEMISTRY
C                         KENT STATE UNIVERSITY
C                         KENT, OHIO 44242
C                         USA
C----------------------------------------------------------------------
C THIS VERSION HAVE BEEN SLIGHTLY MODIFIED BY DANNY PETSCHKE TO EXECUTE
C IT DIRECTLY FROM A GUI BASED SOFTWARE. (11.02.2020)
C
C IF ANY DIFFICULTIES ARISE IN THE USE OF THIS MODIFIED VERSION
C PLEASE CONTACT:         D. PETSCHKE
C                         DEPARTMENT OF CHEMISTRY AND PHARMACY
C                         JM UNIVERSITY WUERZBURG
C                         97070 BAVARIA, GERMANY
C                         DANNY.PETSCHKE@UNI-WUERZBURG.DE
C----------------------------------------------------------------------
C About Input/Output Units:
C  FORT.2:  Contin.Prm    (I) General parameters for Contin
C  FORT.50: Sample.Prm    (I) Specific parameters of the Sample spectrum
C  FORT.55: Sample.Dat    (I) Sample spectrum data
C  FORT.51: Reference.Prm (I) Specific parameters of the Reference spectrum
C  FORT.56: Reference.Dat (I) Reference spectrum data (e.g., Bi-207)
C
C  FORT.33: Complete screen (O)
C  FORT.82: lambda.Dat      (O) Brief final output: lambda values
C  FORT.30: an obscure, not exactly the same duplicate of FORT.82
C  FORT.11: (O) residuals (SUBROUTINE PLRES)
C
C Note: The connections between the units and their respective files
C       have to be established by user himself, probably via utilization
C       of a batch file, e.g., under VAX/VMS and OS/2, by invoking
C	CONTIN.COM and ContinPALS.Cmd, respectively. Do not change the
C       unit numbers (in particular, unit 82) -- unpredictable results
C       may appear.
C
C Modified by G.H. Dai, UMKC, 16-18/Jul/1992.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - BLOCK DATA, INIT, INPUT, SETGRD, USERSI,
C      WRITYT, USERSX, USERNQ, SETNNG, ANALYZ, SETWT
C  WHICH IN TURN CALL - STORIN, READYT, ERRMES, WRITIN, USERIN,
C      USERGR, CQTRAP, USERTR, USEREX, RGAUSS, RANDOM, SETSCA, SEQACC,
C      H12, GETROW, USERK, USERLF, SETREG, USERRG, USEREQ, ELIMEQ,
C      LH1405, SVDRS2, QRBD, G1,G2, DIFF, DIAREG, DIAGA, SETGA1,
C      SETVAL, LDPETC, LDP, NNLS, CVNEQ, FISHNI, GAMLN,
C      BETAIN, PLPRIN, USEROU, MOMENT, MOMOUT, RUNRES, GETPRU, GETYLY,
C      PGAUSS, PLRES, SETSGN, ANPEAK, UPDSGN, UPDDON, FFLAT, UPDLLS,
C      USERWT
C-----------------------------------------------------------------------
      DOUBLE PRECISION PRECIS, RANGE
      DOUBLE PRECISION A, AA, AEQ, AINEQ, PIVOT, REG, RHSNEQ,
     1 S, SOLBES, SOLUTN, SSCALE, VALPCV, VALPHA, VK1Y1, WORK
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      LOGICAL LBIND
C
C***********************************************************************
C  THE INSTRUCTIONS SET OFF BY ASTERISKS DESCRIBE ALL POSSIBLE CHANGES
C      THAT YOU MAY HAVE TO MAKE IN THIS MAIN SUBPROGRAM.  (SEE ALSO THE
C      CHANGES IN THE BLOCK DATA AND USER SUBPROGRAMS.)  THESE CHANGES
C      IN THE MAIN SUBPROGRAM ARE ONLY NECESSARY IF YOU CHANGE MY, MA,
C      MG, MREG, MINEQ, MEQ, MDONE, OR MWORK IN THE DATA STATEMENT
C      BELOW.  IF YOU DO, THEN THE FOLLOWING DIMENSIONS MUST BE
C      READJUSTED AS DESCRIBED BELOW -
C
      DIMENSION T(4000), SQRTW(4000), Y(4000), EXACT(4000), YLYFIT(4000)
      DIMENSION G(504), CQUAD(504), VK1Y1(504), S(504,3), VALPHA(504),
     1 VALPCV(504), SOLUTN(504), IISIGN(504), SOLBES(504),
     2 AA(504,504), SSCALE(504)
      DIMENSION AINEQ(504,504), RHSNEQ(504), LBIND(504)
      DIMENSION A(504,504), IWORK(504)
      DIMENSION REG(504,504)
      DIMENSION AEQ(11,504), PIVOT(11)
      DIMENSION WORK(300000)
      DIMENSION LSDONE(1,3,2), VDONE(1)
C
C  THE ABOVE DIMENSION STATEMENTS MUST BE ADJUSTED AS FOLLOWS -
C
C     DIMENSION T(MY), SQRTW(MY), Y(MY), EXACT(MY), YLYFIT(MY)
C     DIMENSION G(MG), CQUAD(MG), VK1Y1(MG), S(MG,3), VALPHA(MG),
C    1 VALPCV(MG), SOLUTN(MG), IISIGN(MG), SOLBES(MG),
C    2 AA(MG,MG), SSCALE(MG)
C     DIMENSION AINEQ(MINEQ,MG), RHSNEQ(MINEQ), LBIND(MINEQ)
C     DIMENSION A(MA,MG), IWORK(MA)
C     DIMENSION REG(MREG,MG)
C     DIMENSION AEQ(MEQ,MG), PIVOT(MEQ)
C     DIMENSION WORK(MWORK)
C     DIMENSION LSDONE(MDONE,3,2), VDONE(MDONE)
C***********************************************************************
C
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
C
C***********************************************************************
C  YOU CAN SAVE STORAGE BY MAKING THE INTEGERS IN THE FOLLOWING DATA
C      STATEMENT AS SMALL AS THE SIZE OF YOUR PROBLEM WILL ALLOW.  (SEE
C      USERS MANUAL FOR THE MINIMUM ALLOWABLE VALUES.)
C
      DATA MY/4000/, MA/504/, MG/504/, MREG/504/, MINEQ/504/, MEQ/11/,
     1 MDONE/1/, MWORK/300000/
C
C  IF YOU CHANGE THE ABOVE DATA STATEMENT, THEN THE DIMENSION
C      STATEMENTS ABOVE MUST BE READJUSTED, AS DESCRIBED ABOVE.
C
C  THIS IS THE EN OF ALL POSSIBLE CHANGES THAT YOU MIGHT HAVE TO MAKE
C      IN THE MAIN PROGRAM,
C      EXCEPT THAT IF YOUR SYSTEM DOES NOT AUTOMATICALLY
C      OPEN INPUT AND OUTPUT FILES FOR YOU, THEN YOU MIGHT HAVE TO OPEN
C      THEM HERE AND GIVE THEM THE NUMBERS NIN (FOR THE INPUT) AND
C      NOUT (FOR THE OUTPUT), WHERE NIN AND NOUT HAVE BEEN SET IN THE
C      BLOCK DATA SUBPROGRAM.
C  IN ADDITION, IF YOU ARE GOING TO INPUT IUNIT.GE.0, THEN YOU MAY
C      HAVE TO OPEN A TEMPORARY SCRATCH FILE NUMBERED IUNIT.  DO THIS
C      DIRECTLY AFTER STATEMENT 100.  THIS IS NOT NECESSARY IF IUNIT
C      IS NEGATIVE OR IF YOUR SYSTEM OPENS FILES AUTOMATICALLY.
C***********************************************************************
C
C-----------------------------------------------------------------------
C  ERRSET IS CALLED TO INHIBIT DIAGNOSTICS OCCURING AS A RESULT OF
C         FLOATING POINT UNDERFLOW WITH THE IBM VS FORTRAN COMPILER
C  SUPPRESSING DIAGNOSTICS MAY NOT BE NECESSARY WITH OTHER COMPILERS
C-----------------------------------------------------------------------
C      CALL ERRSET(208,256,-1,1,0,0)
C-----------------------------------------------------------------------
C  INITIALIZE VARIABLES
C-----------------------------------------------------------------------
      CALL INIT
C-----------------------------------------------------------------------
C  READ INPUT DATA
C-----------------------------------------------------------------------
      IFILE=29
  100 CALL INPUT (EXACT,G,MA,MEQ,MG,MINEQ,MREG,MWORK,MY,SQRTW,T,Y)
      IFILE=IFILE+1
C-----------------------------------------------------------------------
C  SET UP QUADRATURE GRID
C-----------------------------------------------------------------------
      CALL SETGRD (CQUAD,G,GMNMX,IGRID,IQUAD,MG,NG,NOUT)
C-----------------------------------------------------------------------
C  CALCULATE SIMULATED DATA
C-----------------------------------------------------------------------
      IF (SIMULA) CALL USERSI (EXACT,G,MG,MY,SQRTW,T,Y)
C-----------------------------------------------------------------------
C  WRITE OUT SIMULATED DATA
C-----------------------------------------------------------------------
      IF (SIMULA) CALL WRITYT (EXACT,G,IPRINT,IUSROU,IWT,MG,NOUT,NY,
     1 PRY,SIMULA,SQRTW,T,Y)
C-----------------------------------------------------------------------
C  PUT SECOND CURVE TO BE PLOTTED WITH SOLUTION IN EXACT.
C-----------------------------------------------------------------------
      IF (.NOT.ONLY1) CALL USERSX (EXACT,G,MG)
      NINEQ=0
      NGL=NG+NLINF
      NGLP1=NGL+1
C-----------------------------------------------------------------------
C  SET SPECIAL USER-SUPPLIED INEQUALITY CONSTRAINTS
C-----------------------------------------------------------------------
      IF (DOUSNQ) CALL USERNQ (AINEQ,MG,MINEQ)
C-----------------------------------------------------------------------
C  SET NG NONNEGATIVITY CONSTRAINTS AT ALL NG GRID POINTS
C-----------------------------------------------------------------------
      IF (NONNEG) CALL SETNNG (AINEQ,MINEQ,NG,NGLP1,NINEQ)
      IF (IWT.EQ.1 .OR. IWT.EQ.4) GO TO 200
C-----------------------------------------------------------------------
C  DO A COMPLETE PRELIMINARY UNWEIGHTED ANALYSIS TO GET A SMOOTH FIT
C      TO THE DATA.  THIS SMOOTH CURVE IS THEN USED TO CALCULATE THE
C      WEIGHTS.
C-----------------------------------------------------------------------
      CALL ANALYZ (1,
     1 A,AA,AEQ,AINEQ,CQUAD,EXACT,G,IISIGN,IWORK,LBIND,LSDONE,MA,
     2 MDONE,MEQ,MG,MINEQ,MREG,MWORK,MY,PIVOT,REG,RHSNEQ,S,SOLBES,
     3 SOLUTN,SQRTW,SSCALE,T,VALPCV,VALPHA,VDONE,VK1Y1,WORK,
     4 Y,YLYFIT)
C-----------------------------------------------------------------------
C  CALCULATE SQRTW (SQUARE ROOT OF LEAST SQUARES WEIGHTS).
C-----------------------------------------------------------------------
      CALL SETWT (
     1 CQUAD,G,IUNIT,IWT,MWORK,MY,NERFIT,NG,NGL,NLINF,NOUT,NY,PRWT,
     2 SOLBES,SQRTW,SRANGE,SSCALE,T,WORK,Y,YLYFIT)
C-----------------------------------------------------------------------
C  DO FINAL WEIGHTED ANALYSIS.
C-----------------------------------------------------------------------
  200 CALL ANALYZ (2,
     1 A,AA,AEQ,AINEQ,CQUAD,EXACT,G,IISIGN,IWORK,LBIND,LSDONE,MA,
     2 MDONE,MEQ,MG,MINEQ,MREG,MWORK,MY,PIVOT,REG,RHSNEQ,S,SOLBES,
     3 SOLUTN,SQRTW,SSCALE,T,VALPCV,VALPHA,VDONE,VK1Y1,WORK,
     4 Y,YLYFIT)
C       PRINT*,'NG, NY, MY=', NG, NY,MY
       WRITE(IFILE, 3003)NG
       DO 205 J=1, NG
         WRITE(IFILE, 3003)J, G(J), YLYFIT(J)
  205  CONTINUE
 3003  FORMAT(I5, 2F20.8)
       IF (.NOT.LAST) GO TO 100
C close files safely
      CLOSE(IFILE)
      CLOSE(33)
      CLOSE(82)
      CLOSE(2)
      CLOSE(50)
      CLOSE(51)
      CLOSE(55)
      CLOSE(56)
      CLOSE(11)
      END
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  BLOCK DATA SUBPROGRAM.
      BLOCK DATA
      DOUBLE PRECISION PRECIS, RANGE
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
C
C***********************************************************************
C  YOU MUST SET THE FOLLOWING 4 VARIABLES TO VALUES APPROPRIATE FOR
C      YOUR COMPUTER.  (SEE USERS MANUAL.)
C     DATA RANGE/1.E35/, SRANGE/1.E35/, NIN/2/, NOUT/6/!SP
      DATA RANGE/1.D35/, SRANGE/1.E35/, NIN/2/, NOUT/33/
C***********************************************************************
C
C
C***********************************************************************
C  CONTIN WILL USE THE VALUES OF THE CONTROL VARIABLES THAT ARE IN THE
C      DATA STATEMENTS BELOW UNLESS YOU INPUT DIFFERENT VALUES.  TO SAVE
C      INPUTTING THESE OFTEN, YOU CAN CHANGE THE VALUES BELOW TO THOSE
C      THAT YOU WILL USUALLY USE.
C  THE FOLLOWING DATA STATEMENTS CONTAIN (IN ALPHABETICAL ORDER) THE
C      REAL, INTEGER, AND LOGICAL CONTROL VARIABLES, IN THAT ORDER.
      DATA ALPST/2*0./, DFMIN/2./, GMNMX/2*0./, PLEVEL/4*.5/,
     1 RSVMNX/2*1., 2*0./, RUSER/100*0./,
     2 SRMIN/.01/, YREF/4000*0./,CK/504*0./
      DATA ICRIT/2*1/,
     1 IFORMT/1H(, 1H5, 1HE, 1H1, 1H5, 1H., 1H6, 1H), 62*1H /,
     2 IFORMW/1H(, 1H5, 1HE, 1H1, 1H5, 1H., 1H6, 1H), 62*1H /,
     3 IFORMY/1H(, 1H5, 1HE, 1H1, 1H5, 1H., 1H6, 1H), 62*1H /,
     4 IGRID/2/, IPLFIT/2*2/, IPLRES/2*2/, IPRINT/2*4/, IQUAD/3/,
     5 IUNIT/-1/, IUSER/9*0, 2, 7*0, 50, 32*0/, IUSROU/2*0/, IWT/1/,
     6 LINEPG/60/, LSIGN/16*0/, MIOERR/5/, MOMNMX/-1, 3/, MPKMOM/5/,
     7 MQPITR/35/, NENDZ/2, 2/, NEQ/0/, NERFIT/10/, NFLAT/8*0/, NG/31/,
     8 NINTT/1/, NLINF/0/, NNSGN/2*0/, NORDER/2/, NQPROG/6, 6/,
     9 NSGN/4*0/
      DATA DOCHOS/.TRUE./, DOMOM/.TRUE./, DOUSIN/.TRUE./,
     1 DOUSNQ/.FALSE./, LAST/.TRUE./,
     2 LUSER/30*.FALSE./, NEWPG1/.FALSE./, NONNEG/.TRUE./,
     3 ONLY1/.TRUE./, PRWT/.FALSE./, PRY/.FALSE./,
     4 SIMULA/.FALSE./
C***********************************************************************
C
C
C***********************************************************************
C  IF YOU MAKE ANY CHANGES TO CONTIN, YOU SHOULD PUT A NAME (UP TO 6
C      CHARACTERS) IN IAPACK TO UNIQUELY IDENTIFY YOUR VERSION OF
C      CONTIN.  THIS WILL BE PRINTED IN THE HEADING OF VARIOUS PARTS OF
C      THE OUTPUT.  YOU MUST SPECIFY THE NAME IN THE FOLLOWING STATEMENT
      DATA IAPACK/1HP,1HA, 1HL, 1HS, 1H-, 1H2/
C***********************************************************************
C
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE USEREQ.  THIS IS A USER-SUPPLIED ROUTINE (NEEDED
C      WHEN NEQ IS INPUT POSITIVE) TO PUT THE EQUALITY-CONSTRAINT
C      MATRIX IN THE FIRST NEQ ROWS AND NGL COLUMNS OF AEQ, AND
C      THE RIGHT-HAND-SIDE OF THE EQUALITIES IN COLUMN NGLP1=NGL+1.
C  CQUAD CONTAINS THE COEFFICIENTS OF THE QUADRATURE FORMULA THAT WERE
C      SET IN SETGRD.
C  NOTE - IF WEIGHTS ARE TO BE CALCULATED (I.E., IF IWT=2,3, OR 5), THEN
C      USEREQ WILL BE CALLED TWICE.  THEREFORE IT IS BEST TO HAVE ANY
C      DATA NEEDED BY USEREQ READ IN ONLY ONCE AND STORED, E.G., IN
C      RUSER, AS ILLUSTRATED BELOW.
C  SEE THE USERS MANUAL FOR THE POSITION IN THE INPUT
C      DATA DECK OF ANY INPUT FOR THIS USER SUBPROGRAM.
C  BELOW IS ILLUSTRATED THE CASE WHERE THE END POINTS AND THE
C      INTEGRAL OVER THE SOLUTION CAN BE CONSTRAINED -
C      IF NEQ=1, THEN THE SOLUTION IS CONSTRAINED TO BE RUSER(1) AT
C        THE GRID POINT NG (THE LAST POINT).
C      IF NEQ=2, THEN, IN ADDITION, THE SOLUTION IS CONSTRAINED TO
C        RUSER(2) AT GRID POINT 1
C      IF NEQ=3, THEN, IN ADDITION, THE INTEGRAL OVER THE SOLUTION
C      (USING THE QUADRATURE APPROXIMATION) IS CONSTRAINED TO BE
C      RUSER(6).  NEQ = 1, 2 OR 3 AND RUSER(J), J=1, (AND 2 AND 6
C      IF NEQ=2 OR 3) WOULD HAVE TO HAVE BEEN PREVIOUSLY INPUT.
      SUBROUTINE USEREQ (AEQ,CQUAD,MEQ,MG)
      DOUBLE PRECISION PRECIS, RANGE
      DOUBLE PRECISION AEQ
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      DIMENSION AEQ(MEQ,MG), CQUAD(MG)
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
C     ZERO=0.E0!SP
      ZERO=0.D0
C     ONE=1.E0!SP
      ONE=1.D0
C-----------------------------------------------------------------------
C  YOU MUST REPLACE THE FOLLOWING STATEMENTS WITH THOSE APPROPRIATE
C      FOR YOUR APPLICATION.
C-----------------------------------------------------------------------
      IF (NEQ.GE.1 .AND. NEQ.LE.3) GO TO 105
 5105 FORMAT (/6H NEQ =,I3,28H IS NOT 1, 2 OR 3 IN USEREQ.)
      WRITE (33,5105) NEQ
      STOP
  105 L=MIN0(NEQ,2)
      DO 110 J=1,L
        DO 120 K=1,NGL
          AEQ(J,K)=ZERO
  120   CONTINUE
        AEQ(J,NGLP1)=RUSER(J)
  110 CONTINUE
      AEQ(1,NG)=ONE
      IF (NEQ .GT. 1) AEQ(2,1)=ONE
      IF (NEQ .NE. 3) GO TO 800
      DO 130 K=1,NGL
        AEQ(3,K)=ZERO
        IF (K .LE. NG) AEQ(3,K)=CQUAD(K)
  130 CONTINUE
      AEQ(3,NGLP1)=RUSER(6)
  800 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  FUNCTION USEREX.  THIS IS A USER-SUPPLIED FUNCTION (ONLY USED
C      IF SIMULA=.TRUE.) TO EVALUATE THE NOISE-FREE VALUE OF THE
C      SIMULATED DATA AT T(IROW) (THE INDEPENDENT VARIABLE AT THE
C      DATA POINT IROW).
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - USERLF, USERK, ERRMES
C  WHICH IN TURN CALL - USERTR
C-----------------------------------------------------------------------
      FUNCTION USEREX (IROW,T,MY,G,MG)
      DOUBLE PRECISION PRECIS, RANGE
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      DIMENSION T(MY), IHOLER(6), ADUM(1), G(MG)
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
       DATA IHOLER/1HU, 1HS, 1HE, 1HR, 1HE, 1HX/
C-----------------------------------------------------------------------
C  THE FOLLOWING STATEMENTS SHOULD BE REPLACED WITH THE ONES
C      APPROPRIATE FOR YOUR SIMULATION.
C-----------------------------------------------------------------------
      USEREX = 0.
  800 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE USERGR.  THIS IS A USER-SUPPLIED ROUTINE (ONLY CALLED
C      WHEN IGRID IS INPUT AS 3) FOR COMPUTING A NONSTANDARD GRID G
C      AND THE QUADRATURE WEIGHTS CQUAD.
C  IN THE EXAMPLE BELOW, G IS SIMPLY READ IN.  CQUAD IS
C      THEN COMPUTED FOR THE TRAPEZOIDAL RULE.
C  SEE THE USERS MANUAL FOR THE POSITION IN THE INPUT
C      DATA DECK OF ANY INPUT FOR THIS USER SUBPROGRAM.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - CQTRAP
C-----------------------------------------------------------------------
      SUBROUTINE USERGR (G,CQUAD,MG)
      DOUBLE PRECISION PRECIS, RANGE
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      DIMENSION G(MG), CQUAD(MG)
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
C-----------------------------------------------------------------------
C  YOU MUST REPLACE THE FOLLOWING STATEMENTS WITH THOSE APPROPRIATE
C      FOR YOUR APPLICATION.
C-----------------------------------------------------------------------
      READ (NIN,5100) (G(J),J=1,NG)
 5100 FORMAT (5E15.6)
C-----------------------------------------------------------------------
C  CQTRAP USES G TO PUT TRAPEZOIDAL RULE WEIGHTS IN CQUAD.
C-----------------------------------------------------------------------
      CALL CQTRAP (G,CQUAD,NG)
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE USERIN.  THIS IS A USER-SUPPLIED ROUTINE (ONLY CALLED
C      WHEN DOUSIN=.TRUE.) THAT IS CALLED RIGHT AFTER THE INITIALIZATION
C      AND INPUT OF THE COMMON VARIABLES, T, Y, YREF AND THE LEASTS
C      SQUARES WEIGHTS. THEREFORE, IT CAN BE USED TO MODIFY ANY OF THESE
C  SEE THE USERS MANUAL FOR THE POSITION IN THE INPUT
C      DATA DECK OF ANY INPUT FOR THIS USER SUBPROGRAM.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - ERRMES
C-----------------------------------------------------------------------
      SUBROUTINE USERIN (T,Y,SQRTW,MY)
      DOUBLE PRECISION PRECIS, RANGE
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      DIMENSION T(MY), Y(MY), SQRTW(MY)
      DIMENSION TYREF(4000)
      DIMENSION IHOLER(6)
      DIMENSION CORR(3), PRECOR(3), G(3)
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
      DATA IHOLER /1HU, 1HS, 1HE, 1HR, 1HI, 1HN/
C-----------------------------------------------------------------------
C  YOU MUST REPLACE THE FOLLOWING STATEMENTS WITH THOSE APPROPRIATE
C      FOR YOUR APPLICATION.
C-----------------------------------------------------------------------
C THE FOLLOWING STATEMENTS SUBTRACT THE BACKGROUND FROM THE REFERENCE
C DATA. THIS IS ALWAYS REQUIRED. THE VALUE OF THE BACKGROUND TERM IS
C INPUT AS RUSER(59). THE TOTAL COUNTS FOR THE REFERENCE AND SAMPLE
C (CORRECTED FOR BACKGROUND COUNTS) ARE CALCULATED AS YRTOT AND YTOT.
C-----------------------------------------------------------------------
      DO 10 I = 1,NY
   10 YREF(I) = YREF(I) - RUSER(59)
      YTOT = 0.
      YRTOT = 0.
      DO 305 I =1,NY
      YTOT = YTOT + Y(I) - RUSER(58)
  305 YRTOT = YRTOT + YREF(I)
      RUSER(80) = YTOT/(YRTOT*RUSER(35))
C-----------------------------------------------------------------------
C  IF IUSER(1) = 1
C  THE STATEMENTS BELOW WILL MODIFY YREF BY CONVOLUTION WITH A FUNCTION
C  WHICH IS APPROXIMATED BY THE VALUES RUSER(41),......RUSER(49) AS
C  OCCURS WHEN THE REFERENCE AND SAMPLE HAVE DIFFERENT POSITRON
C  IMPLANTATION PROFILES
C-----------------------------------------------------------------------
      IF (IUSER(1) .NE. 1) GOTO 250
      DO 40 I=1,NY
   40 TYREF(I) = 0.
      NYMF = NY - 5
      DO 50 I=5,NYMF
      DO 60 J=1,9
      JF = J+40
      IX = I-5+J
      TYREF(I) = TYREF(I) + YREF(IX)*RUSER(JF)
   60 CONTINUE
   50 CONTINUE
      DO 70 I=5,NYMF
   70 YREF(I)=TYREF(I)
C-----------------------------------------------------------------------
C  IF IUSER(2) = 1, THE FOLLOWING STATEMENTS WILL CORRECT Y(T) FOR
C  SOURCE COMPONENTS IN THE REFERENCE AND SAMPLE. UP TO THREE COMPONENTS
C  MAY APPEAR IN EACH.
C  NS = IUSER(43) IS THE NUMBER OF SOURCE COMPONENTS IN THE SAMPLE
C  NRS = IUSER(40) IS THE NUMBER OF SOURCE COMPONENTS IN THE REFERENCE
C
C  THE PARAMETERS FOR SOURCE COMPONENTS ARE:
C        REFERENCE     LAMBDA 1     RUSER(51),   ALPHA 1     RUSER(61)
C                      LAMBDA 2     RUSER(52),   ALPHA 2     RUSER(62)
C                      LAMBDA 3     RUSER(53),   ALPHA 3     RUSER(63)
C
C        SAMPLE        LAMBDA 1     RUSER(54),   ALPHA 1     RUSER(64)
C                      LAMBDA 2     RUSER(55),   ALPHA 2     RUSER(65)
C                      LAMBDA 3     RUSER(56),   ALPHA 3     RUSER(66)
C
C        SAMPLE BACKGROUND          RUSER(58)
C
C-----------------------------------------------------------------------
  250 IF (IUSER(2) .NE. 1) GOTO 800
      NRS = IUSER(40)
      NS = IUSER(43)
      DENOMR = 1.
      DENOMS = 1.
      DO 307 J = 1,NRS
      JR = J + 60
  307 DENOMR = DENOMR - RUSER(JR)
      DO 310 J = 1,NS
      JS = J + 63
  310 DENOMS = DENOMS - RUSER(JS)
C--------------------------------------------------------------------
C     RUSER(80) IS THE NORMALIZATION CONSTANT CALCULATED FOR USE BY
C     USERK AND USERLF WHEN SOURCE CORRECTIONS ARE APPLIED
C--------------------------------------------------------------------
      RUSER(80) = YTOT*DENOMS/(RUSER(35)*YRTOT*DENOMR)
      DO 320 J = 1,NRS
      JF = J + 50
      JS = J + 60
  320 PRECOR(J) = RUSER(JS)*RUSER(JF)/(RUSER(35)*DENOMR)
      DO 400 I = 1,NY
      YMB = Y(I) - RUSER(58)
      DO 390 J = 1,NRS
      JF = J + 50
      IF (I .NE. 1) GO TO 350
      CORR(J) = 0.5*RUSER(30)*YMB
      GO TO 380
  350 EX = RUSER(JF)*RUSER(30)
      CORR(J) = CORR(J) + 0.5*RUSER(30)*YLAST
      CORR(J) = CORR(J)*EXP(-EX) + 0.5*RUSER(30)*YMB
  380 TEMPC = YMB + (RUSER(35)-RUSER(JF))*CORR(J)
      YLAST = YMB
  390 Y(I) = Y(I) + PRECOR(J)*TEMPC
  400 CONTINUE
      DO 430 J = 1,NS
      JST = J + 63
      JFT = J + 53
      G(J) = RUSER(JFT)
      XNUM = RUSER(JFT)*RUSER(JST)*YTOT
      XDEN = RUSER(35)*DENOMR*YRTOT
  430 PRECOR(J) = XNUM/XDEN
      DO 500 I = 1,NY
      DO 450 J = 1,NS
C----------------------------------------------------------------------
C THE CORRECTION FOR SOURCE TERMS IN THE SAMPLE IS CALCULATED WITH USERK
C AND IS DIVIDED BY RUSER(80) TO REMOVE THE NOMALIZATION TERM
C-----------------------------------------------------------------------
      CORR(J) = PRECOR(J)*USERK(I,1,J,G)/RUSER(80)
  450 Y(I) = Y(I) - CORR(J)
  500 CONTINUE
  800 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  FUNCTION USERK.  THIS IS A USER-SUPPLIED ROUTINE (ALWAYS NEEDED)
C      TO COMPUTE THE FREDHOLM KERNEL, USERK, WHICH DEPENDS ON T(JT)
C      (THE INDEPENDENT VARIABLE AT DATA POINT JT) AND G(JG) (THE
C      VALUE OF THE JG TH GRID POINT.
C      THE STATEMENTS BELOW CALCULATE THE KERNEL APPLICABLE
C      TO POSITRON ANNIHILATION LIFETIME SPECTROSCOPY WHICH IS USED
C      WHEN THE INSTRUMENT RESOLUTION FUNCTION IS KNOWN THROUGH ITS
C      EFFECTS ON A REFERENCE SPECTRUM (YREF) WITH A WELL-KNOWN
C      SINGLE ANNIHILATION RATE, RUSER(35).
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - ERRMES, USERTR
C-----------------------------------------------------------------------
      FUNCTION USERK (JT,T,JG,G)
      DOUBLE PRECISION PRECIS, RANGE
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      DIMENSION T(JT), G(2)
      DIMENSION IHOLER(6)
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
      DATA IHOLER/1HU, 1HS, 1HE, 1HR, 1HK, 1H /
      IF (JT.GT.NY .OR. JG.GT.NG+1 .OR. MIN0(JT,JG).LE.0) CALL
     1 ERRMES (1,.TRUE.,IHOLER,NOUT)
C-----------------------------------------------------------------------
C  THE FOLLOWING STATEMENTS SHOULD BE REPLACED BY THOSE
C      APPROPRIATE FOR YOUR KERNEL.
C  FOR EXAMPLE, FOR THE LAPLACE INTEGRAL EQUATION, YOU WOULD
C      SIMPLY REPLACE ALL BUT THE LAST TWO STATEMENTS BELOW BY -
C     USERK=EXP(-T(JT)*G(JG))
C  IT MAY NOT BE NECESSARY TO GUARD AGAINST UNDERFLOW IN EXP AS IS
C      DONE BELOW, BUT A FEW COMPILERS ABORT AT UNDERFLOW IN EXP.
C      (EXMAX IS SET IN INIT TO ALOG(SRANGE), I.E., IT IS THE
C      LARGEST REASONABLE EXPONENT IN EXP.)
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C  GENERAL FORM OF KERNEL - WHEN IUSER(10)=4.
C-----------------------------------------------------------------------
  400 IF (IUSER(10) .NE. 4) GO TO 470
      IF (RUSER(22).LT.0. .AND. G(JG).LT.0.) CALL ERRMES(5,.TRUE.,
     1 IHOLER,NOUT)
      EX = RUSER(21)*T(JT)*G(JG)**RUSER(22)
      PREEXP = G(JG)**RUSER(23)
      GO TO 500
C-----------------------------------------------------------------------
C        CONVOLUTED KERNEL- WHEN IUSER(10)=6
C USED WHEN THE RESOLUTION FUNCTION IS KNOWN ONLY THROUGH ITS EFFECT
C ON A REFERENCE SPECTRUM WITH A SINGLE KNOWN RATE, RUSER(35)
C THIS ALGORITHM TAKES ADVANTAGE OF THE FACT THAT USERK IS CALLED SUCH
C THAT JG GOES FROM 1 TO NG AND GETROW,WHICH CALLS USERK, IS ITSELF
C CALLED SUCH THAT JT GOES FROM 1 TO NY
C CK STORES THE VALUES OF THE KERNEL FOR THE (JT-1)TH DATA POINT
C-----------------------------------------------------------------------
  470 IF (JT .NE. 1) GO TO 480
      CK(JG)=0.5*RUSER(30)*YREF(JT)
      USERK=CK(JG)*(RUSER(35)-G(JG))*G(JG)**RUSER(23)
      USERK = USERK*RUSER(80)
      GO TO 600
  480 JTM=JT-1
      EX=G(JG)*RUSER(30)
      RFACT=(RUSER(35)-G(JG))*G(JG)**RUSER(23)
      CKERN=(CK(JG)+0.5*RUSER(30)*YREF(JTM))*EXP(-EX)
      CKERN=CKERN+0.5*RUSER(30)*YREF(JT)
      CK(JG)=CKERN
      USERK=0.
      IF (EX .LT. EXMAX) USERK=RUSER(80)*(CKERN*RFACT+YREF(JT))
      GO TO 600
  500 USERK=0.
      IF (EX .LT. EXMAX) USERK=PREEXP*EXP(-EX)
  600 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  FUNCTION USERLF.  THIS IS A USER-SUPPLIED ROUTINE (NEEDED IF
C      NLINF IS INPUT POSITIVE) TO CALCULATE THE NLINF ADDITIONAL
C      KNOWN FUNCTIONS THAT ARE PRESENT IN UNKNOWN AMOUNTS
C      IN THE DATA.
C  JY = THE SUBSCRIPT OF THE DATA POINT.
C  JLINF = INDEX TELLING WHICH OF THE NLINF FUNCTIONS IS TO BE
C      EVALUATED.  (1 .LE. JLINF .LE. NLINF)
C  NYDIM = THE DIMENSION OF THE ARRAY T.  IT CAN BE MY OR NY.
C THE STATEMENTS BELOW ADD TWO LINEAR TERMS:
C WHEN JLINF = 1, USERLF IS SET = 1 TO ACCOUNT FOR A CONSTANT
C      BACKGROUND
C WHEN JLINF = 2, USERLF CALCULATES THE CONSTANT TO ACCOUNT FOR A
C      ZERO-TIME SHIFT BETWEEN THE REFERENCE AND SAMPLE DATA
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - ERRMES
C-----------------------------------------------------------------------
      FUNCTION USERLF (JY,JLINF,T,NYDIM)
      DOUBLE PRECISION PRECIS, RANGE
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      DIMENSION T(NYDIM), IHOLER(6)
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
      DATA IHOLER/1HU, 1HS, 1HE, 1HR, 1HL, 1HF/
      IF (JY.GT.NY .OR. JY.LE.0) CALL ERRMES (1,.TRUE.,IHOLER,NOUT)
C-----------------------------------------------------------------------
C  THE FOLLOWING STATEMENTS MUST BE REPLACED BY THE APPROPRIATE
C      ONES FOR YOUR ADDITIVE FUNCTIONS.
C-----------------------------------------------------------------------
      IF (JLINF.LT.1 .OR. JLINF.GT.2) CALL ERRMES (2,.TRUE.,IHOLER,
     1 NOUT)
      USERLF=0.
  100 IF(JLINF .EQ. 1) GO TO 400
C-----------------------------------------------------------------------
C  CORRECTION FOR SHIFT IN REFERENCE AND SAMPLE DATA
C-----------------------------------------------------------------------
      IF (JY .EQ. NY) GO TO 480
      IF (JY .EQ. 1) GO TO 470
      JYP1 = JY+1
      JYM1 = JY-1
      USERLF = (YREF(JYP1)-YREF(JYM1))/(2.0*RUSER(30))
      GO TO 490
  470 USERLF = (YREF(2)-YREF(1))/RUSER(30)
      GO TO 490
  480 NYM1 = NY-1
      USERLF = (YREF(NY)-YREF(NYM1))/RUSER(30)
  490 USERLF = RUSER(35)*YREF(JY) + USERLF
      USERLF = RUSER(80)*USERLF
      GO TO 500
C----------------------------------------------------------------------
C USERLF = 1 TO ACCOUNT FOR CONSTANT BACKGROUND
C----------------------------------------------------------------------
  400 USERLF=1.
  500 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE USERNQ.  THIS IS A USER-SUPPLIED ROUTINE (ONLY
C      CALLED WHEN DOUSNQ IS INPUT AS .TRUE.) TO SET NINEQ
C      (THE NO. OF INEQUALITY CONSTRAINTS) AND TO PUT THE
C      INEQUALITY-CONSTRAINT MATRIX IN THE FIRST NINEQ
C      ROWS OF AINEQ AND TO PUT THE RIGHT HAND SIDES OF THE
C      INEQUALITIES IN COLUMN NGLP1 OF AINEQ.
C  I.E., (SUM FROM J=1 TO NGL OF (AINEQ(I,J)*SOLUTION(J))) .GE.
C      AINEQ(I,NGLP1), I=1,NINEQ.  SEE EQ. (3.6).
C  NOTE - IF THE SOLUTION IS TO BE NONNEGATIVE AT ALL NG GRID
C      POINTS, DO NOT USE USERNQ TO SET THESE CONSTRAINTS -
C      SIMPLY INPUT NONNEG=.TRUE. INSTEAD.
C  SEE THE USERS MANUAL FOR THE POSITION IN THE INPUT
C      DATA DECK OF ANY INPUT FOR THIS USER SUBPROGRAM.
C  BELOW IS ILLUSTRATED THE CASE WHERE THE NLINF COEFFICIENTS OF
C      THE NLINF LINEAR FUNCTIONS ARE CONSTRAINED TO BE
C      NONNEGATIVE.
C  NOTE: WHEN ZERO-TIME SHIFT CORRECTIONS ARE ACTIVE (I.E. NLINF = 2)
C  DOUSNQ MUST BE INPUT AS .FALSE.
C----------------------------------------------------------------------
      SUBROUTINE USERNQ (AINEQ,MG,MINEQ)
      DOUBLE PRECISION PRECIS, RANGE
      DOUBLE PRECISION AINEQ, ONE, ZERO
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      DIMENSION AINEQ(MINEQ,MG)
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
C     ZERO=0.E0!SP
      ZERO=0.D0
C     ONE=1.E0!SP
      ONE=1.D0
C-----------------------------------------------------------------------
C  YOU MUST REPLACE THE FOLLOWING STATEMENTS WITH THOSE APPROPRIATE
C      FOR YOUR APPLICATION.
C-----------------------------------------------------------------------
      IF (NLINF .LE. 0) RETURN
      NINEQ=NLINF
      DO 110 J=1,NINEQ
        DO 120 K=1,NGLP1
          AINEQ(J,K)=ZERO
  120   CONTINUE
        K=NG+J
        AINEQ(J,K)=ONE
  110 CONTINUE
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE USEROU.  THIS IS A USER-SUPPLIED ROUTINE (ONLY CALLED
C      WHEN DOUSOU=.TRUE.) THAT YOU CAN USE TO PRODUCE YOUR OWN EXTRA
C      OUTPUT.
C  G CONTAINS THE NG GRID POINTS.
C  SOL CONTAINS NG+NLINF VALUES - FIRST THE NG SOLUTION VALUES AND THEN
C      THE NLINF LINEAR COEFFICIENTS.
C  EXACT CONTAINS THE NG VALUES OF THE SECOND CURVE TO BE PLOTTED THAT
C      HAS BEEN COMPUTED IN USERSX (ONLY IF ONLY1=.FALSE.).
C  AA IS ( SQUARE ROOT OF THE COVARIANCE MATRIX OF THE SOLUTION)/STDDEV.
C  (CONTIN SETS DOERR=.FALSE. IF IT WAS NOT ABLE TO COMPUTE AA OR
C      STDDEV.  THE ERROR ESTIMATES THEN CANNOT BE COMPUTED AND ARE SET
C      TO ZERO.)
C----------------------------------------------------------------------
      SUBROUTINE USEROU (CQUAD,G,SOL,EXACT,AA,MG,STDDEV,DOERR,NGLEY)
      DOUBLE PRECISION AA
      DOUBLE PRECISION PRECIS, RANGE
      LOGICAL DOCHOS, DOERR, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      DIMENSION CQUAD(MG), G(MG), SOL(MG), EXACT(MG), AA(MG,MG)
      DIMENSION FCAP(3,16), F(3), ERROR(3)
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE,YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE USERRG.  THIS IS A USER-SUPPLIED ROUTINE (NEEDED
C      WHEN NORDER IS INPUT NEGATIVE) TO SET NREG AND TO PUT A
C      SPECIAL USER-DEFINED REGULARIZOR IN THE FIRST NREG COLUMNS
C      AND ROWS OF REG AND THE RIGHT-HAND-SIDE (R.H.S.) OF THE
C      REGULARIZOR IN COLUMN NGLP1 OF REG.
C  NOTE - IF IWT = 1 OR 4, THEN USERRG IS CALLED 2 TIMES.
C         IF IWT = 2, 3, OR 5, THEN USERRG IS CALLED 4 TIMES.
C         THEREFORE, IT IS BEST TO HAVE ANY DATA NEEDED BY USERRG READ
C         IN ONLY ONCE AND STORED (E.G., IN RUSER, AS ILLUSTRATED
C         BELOW).  OTHERWISE, THIS DATA WOULD HAVE TO BE READ 2 OR 4
C         TIMES.
C  SEE THE USERS MANUAL FOR THE POSITION IN THE INPUT
C      DATA DECK OF ANY INPUT FOR THIS USER SUBPROGRAM.
C  BELOW IS ILLUSTRATED A REGULARIZOR THAT PENALIZES DEVIATIONS OF THE
C      SOLUTION FROM AN EXPECTED SOLUTION.  THE IDENTITY MATRIX GOES
C      INTO THE REGULARIZOR, AND THE EXPECTED SOLUTION IS READ INTO
C      RUSER(IUSER(1)),...,RUSER(IUSER(1)+NG-1) AND THEN PUT INTO THE
C      R.H.S. OF THE REGULARIZOR (COLUMN NGLP1 OF REG).  (SEE
C      S. TWOMEY, JACM 10, 97 (1963).)
C      LUSER(1) IS INPUT INITIALLY AS .FALSE. AND THEN SET TO .TRUE.
C      SO THAT THE DATA IS ONLY READ ONCE.
C----------------------------------------------------------------------
      SUBROUTINE USERRG (REG,MREG,MG,NREG)
      DOUBLE PRECISION PRECIS, RANGE
      DOUBLE PRECISION REG
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      DIMENSION REG(MREG,MG)
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
C-----------------------------------------------------------------------
C  YOU MUST REPLACE THE FOLLOWING STATEMENTS WITH THOSE APPROPRIATE
C      FOR YOUR APPLICATION.
C-----------------------------------------------------------------------
      NREG=NG
      DO 110 J=1,NREG
        DO 120 K=1,NGL
          REG(J,K)=0.
  120   CONTINUE
        REG(J,J)=1.
  110 CONTINUE
      J=IUSER(1)
      K=J+NG-1
      IF (LUSER(1)) GO TO 200
 5200 FORMAT (5E15.6)
      READ (NIN,5200) (RUSER(L),L=J,K)
      WRITE (33,5200) (RUSER(L),L=J,K)
      LUSER(1)=.TRUE.
  200 IROW=0
      DO 210 L=J,K
        IROW=IROW+1
        REG(IROW,NGLP1)=RUSER(L)
  210 CONTINUE
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE USERSI.  THIS IS A USER-SUPPLIED ROUTINE (ONLY
C      CALLED WHEN SIMULA IS .TRUE.) FOR CALCULATING EXACT(J)
C      (THE SIMULATED DATA BEFORE NOISE IS ADDED) AND
C      Y(J) (THE SIMULATED NOISY DATA) FOR J=1,NY.
C  EXACT(J) MUST BE COMPUTED IN USEREX.
C  IUSER(3) = STARTING INTEGER FOR RANDOM NUMBER GENERATOR RANDOM.
C  IUSER(3) AND RUSER(3) MUST BE SUPPLIED BY THE USER.
C  IUSER(3) MUST BE BETWEEN 1 AND 2147483646.  IF IT IS NOT, THEN
C      IT IS SET TO THE DEFAULT VALUE OF 30171.
C  SEE THE USERS MANUAL FOR THE POSITION IN THE INPUT
C      DATA DECK OF ANY INPUT FOR THIS USER SUBPROGRAM.
C  BELOW IS ILLUSTRATED THE CASE WHERE ZERO-MEAN
C      NORMALLY DISTRIBUTED PSEUDORANDOM NOISE IS ADDED TO EXACT(J).
C      SD(J), THE STANDARD DEVIATION OF THE NOISE AT POINT J, IS
C      DETERMINED BY IWT AND RUSER(3) AS FOLLOWS -
C      IWT = 1 CAUSES SD(J)=RUSER(3) FOR ALL J.
C      IWT = 2 CAUSES SD(J)=RUSER(3)*SQRT(EXACT(J)), AS APPROPRIATE
C              FOR POISSON STATISTICS.  IN THE POISSON CASE,
C              RUSER(3) IS JUST A SCALE FACTOR FOR THE CASE THAT
C              EXACT(J) IS NOT IN NUMBER OF EVENTS, I.E.,
C              RUSER(3)=SQRT(EXACT(J)/(NO. OF EVENTS IN CHANNEL J)).
C              THUS, EXACT(J)/RUSER(3)**2 IS THE POISSON VARIABLE.
C              IF EXACT(J) IS ALREADY IN NO. OF EVENTS, THEN YOU
C              SHOULD SET RUSER(3)=1.
C      IWT = 3 CAUSES SD(J)=RUSER(3)*EXACT(J).
C      IWT = 4 CAUSES SD(J)=RUSER(3)/SQRTW(J).
C      (SEE ALSO THE USERS MANUAL.)
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - USEREX, RGAUSS, ERRMES
C  WHICH IN TURN CALL - RANDOM, USERK, USERLF, USERTR
C-----------------------------------------------------------------------
      SUBROUTINE USERSI (EXACT,G,MG,MY,SQRTW,T,Y)
      DOUBLE PRECISION PRECIS, RANGE
      DOUBLE PRECISION DUB
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      DIMENSION T(MY), EXACT(MY), Y(MY), SQRTW(MY), G(MG)
      DIMENSION RN(2), IHOLER(6)
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
      DATA IHOLER/1HU, 1HS, 1HE, 1HR, 1HS, 1HI/
      TWOPI=6.2831853072D0
      DIX=DBLE(FLOAT(IUSER(3)))
      IF (DIX.LT.1.D0 .OR. DIX.GT.2147483646.D0) DIX=30171.D0
      DO 150 J=1,NY
        JJ=J
C-----------------------------------------------------------------------
C  RGAUSS DELIVERS TWO NORMAL DEVIATES WITH ZERO MEANS AND STANDARD
C      DEVIATIONS 1.  THEREFORE IT IS ONLY CALLED FOR ODD J.
C-----------------------------------------------------------------------
        K=2-MOD(J,2)
        IF (K .EQ. 1) CALL RGAUSS (RN(1),RN(2),TWOPI,DIX)
C-----------------------------------------------------------------------
C  YOU MUST REPLACE THE FOLLOWING STATEMENTS WITH THOSE APPROPRIATE
C      FOR YOUR APPLICATION.
C-----------------------------------------------------------------------
        EXACT(J)=USEREX(JJ,T,MY,G,MG)
C-----------------------------------------------------------------------
C  THE NEXT STATEMENT TEMPORARILY SETS THE ERROR TO A NORMAL DEVIATE
C      WITH MEAN = ZERO AND STANDARD DEVIATION = RUSER(3).
C-----------------------------------------------------------------------
        ERROR=RUSER(3)*RN(K)
        IF (IWT .NE. 2) GO TO 160
        IF (EXACT(J) .LT. 0.) CALL ERRMES (1,.TRUE.,IHOLER,NOUT)
        ERROR=ERROR*SQRT(EXACT(J))
        GO TO 190
  160   IF (IWT .EQ. 3) ERROR=ERROR*EXACT(J)
        IF (IWT .NE. 4) GO TO 170
        IF (SQRTW(J) .LE. 0.) CALL ERRMES (2,.TRUE.,IHOLER,NOUT)
        ERROR=ERROR/SQRTW(J)
  170   IF (IWT .NE. 5) GO TO 190
C-----------------------------------------------------------------------
C STATEMENTS MAY BE INSERTED HERE TO CALCULATE NOISE IN SPECIAL CASES
C WHEN IWT = 5
C----------------------------------------------------------------------
  190   Y(J)=EXACT(J)+ERROR
  150 CONTINUE
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE USERSX.  THIS IS A USER-SUPPLIED ROUTINE (ONLY
C      CALLED WHEN YOU HAVE INPUT ONLY1=.FALSE.)
C      TO COMPUTE EXACT(J),J=1,NG, WHICH WILL BE PLOTTED WITH
C      EACH SOLUTION.  USUALLY EXACT IS THE EXACT THEORETICAL
C      SOLUTION USED TO SIMULATE YOUR DATA IN USERSI EVALUATED AT
C      THE GRID POINTS G(J),J=1,NG.
C  SEE THE USERS MANUAL FOR THE POSITION IN THE INPUT
C      DATA DECK OF ANY INPUT FOR THIS USER SUBPROGRAM.
C  BELOW IS ILLUSTRATED THE CASE WHERE EXACT IS
C      G(J)**RUSER(8)*EXP(-G(J))/(FACTORIAL OF RUSER(8)), WHERE
C      1. .LE. RUSER(8) .LE. 20. AND THE G(J) ARE NONNEGATIVE.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - GAMLN
C-----------------------------------------------------------------------
      SUBROUTINE USERSX (EXACT,G,MG)
      DOUBLE PRECISION PRECIS, RANGE
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      DIMENSION EXACT(MG), G(MG)
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
C-----------------------------------------------------------------------
C  YOU MUST REPLACE THE FOLLOWING STATEMENTS WITH THOSE APPROPRIATE
C      FOR YOUR EVALUATION OF EXACT.
C-----------------------------------------------------------------------
      IF (RUSER(8).GE.1. .AND. RUSER(8).LE.20.) GO TO 120
 5120 FORMAT (/11H RUSER(8) =,E12.4,27H IS OUT OF RANGE IN USERSX.)
      WRITE (33,5120) RUSER(8)
      STOP
  120 EXMIN=-ALOG(SRANGE)
      FACTL=GAMLN(RUSER(8)+1.)
      DO 150 J=1,NG
        EXACT(J)=0.
        IF (G(J)) 160,150,180
  160   WRITE (33,5160)
 5160   FORMAT (/22H NEGATIVE G IN USEREX.)
        STOP
  180   EX=RUSER(8)*ALOG(G(J))-G(J)-FACTL
        IF (EX .GE. EXMIN) EXACT(J)=EXP(EX)
  150 CONTINUE
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  FUNCTION USERTR.  THIS IS A USER-SUPPLIED ROUTINE
C      FOR COMPUTING THE QUADRATURE-GRID TRANSFORMATION
C      (CALL IT H) H(G) WHEN IFUNCT=1, THE INVERSE TRANSFORMATION
C      WHEN IFUNCT=2, AND THE DERIVATIVE OF THE TRANSFORMATION
C      WHEN IFUNCT=3.  WHEN IGRID=2, G (THE QUADRATURE GRID) WILL
C      BE IN EQUAL INTERVALS OF H(G) RATHER THAN IN EQUAL
C      INTERVALS OF G (AS IT IS WHEN IGRID=1 AND H IS THE
C      IDENTITY TRANSFORMATION).
C  BELOW IS ILLUSTRATED THE CASE H(G)=ALOG(G).  FOR ANOTHER H,
C      YOU CAN REPLACE THE STATEMENTS NUMBERED 210, 220, AND 230.
C      THESE ARE THE ONLY STATEMENTS THAT CAN BE REPLACED.  ALSO
C      NOTE THAT ONLY AN H THAT IS MONOTONIC IN THE RANGE OF
C      INTEGRATION MAKES SENSE.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - ERRMES
C-----------------------------------------------------------------------
      FUNCTION USERTR (X,IFUNCT)
      DOUBLE PRECISION PRECIS, RANGE
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
      DIMENSION IHOLER(6)
      DATA IHOLER/1HU, 1HS, 1HE, 1HR, 1HT, 1HR/
      IF (IFUNCT.LT.1 .OR. IFUNCT.GT.3) CALL ERRMES (1,.TRUE.,
     1 IHOLER,NOUT)
      IF (IGRID .NE. 1) GO TO 200
C-----------------------------------------------------------------------
C  COMPUTE TRANSFORMATION, INVERSE, AND DERIVATIVE FOR IDENTITY
C      TRANSFORMATION.
C-----------------------------------------------------------------------
      USERTR=1.
      IF (IFUNCT .NE. 3) USERTR=X
      RETURN
  200 IF (IGRID .NE. 2) CALL ERRMES (2,.TRUE.,IHOLER,NOUT)
      GO TO (210,220,230),IFUNCT
C-----------------------------------------------------------------------
C  COMPUTE TRANSFORMATION.
C-----------------------------------------------------------------------
  210 USERTR=ALOG(X)
      RETURN
C-----------------------------------------------------------------------
C  COMPUTE INVERSE TRANSFORMATION.
C-----------------------------------------------------------------------
  220 USERTR=EXP(X)
      RETURN
C-----------------------------------------------------------------------
C  COMPUTE DERIVATIVE OF TRANSFORMATION.
C-----------------------------------------------------------------------
  230 USERTR=1./X
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE USERWT.  THIS IS A USER-SUPPLIED ROUTINE (ONLY
C      NEEDED WHEN IWT IS INPUT AS 5) FOR CALCULATING SQRTW (SQUARE
C      ROOTS OF THE LEAST SQUARES WEIGHTS) FROM Y, YLYFIT, AND
C      ERRFIT, AS EXPLAINED IN DETAIL IN THE USERS MANUAL.
C  SEE THE USERS MANUAL FOR THE POSITION IN THE INPUT
C      DATA DECK OF ANY INPUT FOR THIS USER SUBPROGRAM.
C--------------------------------------------------------------------
      SUBROUTINE USERWT (Y,YLYFIT,MY,ERRFIT,SQRTW)
      DOUBLE PRECISION PRECIS, RANGE
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      DIMENSION Y(MY), YLYFIT(MY), SQRTW(MY)
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
C-----------------------------------------------------------------------
C  YOU MUST REPLACE THE FOLLOWING STATEMENTS WITH THOSE APPROPRIATE
C      FOR YOUR APPLICATION.
C-----------------------------------------------------------------------
      DO 200 I = 1,NY
      VAR = (Y(I)-YLYFIT(I))
      DUM=AMAX1(ABS(VAR),ERRFIT)
      SQRTW(I) = 1./DUM
      SQRTW(I) = SQRT(SQRTW(I))
  200 CONTINUE
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE ANALYZ.  DOES COMPLETE CONSTRAINED REGULARIZED
C     ANALYSIS.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - SETSCA, SEQACC, SETREG, USEREQ, ELIMEQ, SVDRS2,
C     ERRMES, DIAREG, DIAGA, SETGA1, SETVAL, LDPETC, RUNRES,
C     ANPEAK, SETSGN, SETNNG
C  WHICH IN TURN CALL - H12, GETROW, USERK, USERLF, USERRG, LH1405,
C     QRBD, G1, G2, DIFF, LDP, CVNEQ, FISHNI, BETAIN, GAMLN,
C     NNLS, PLRES, UPDSGN, UPDDON, FFLAT, UPDLLS,
C     GETPRU, GETYLY, PGAUSS, MOMENT, MOMOUT, PLPRIN, USEROU, USERTR
C-----------------------------------------------------------------------
      SUBROUTINE ANALYZ (ISTAGE,
     1 A,AA,AEQ,AINEQ,CQUAD,EXACT,G,IISIGN,IWORK,LBIND,LSDONE,MA,
     2 MDONE,MEQ,MG,MINEQ,MREG,MWORK,MY,PIVOT,REG,RHSNEQ,S,SOLBES,
     3 SOLUTN,SQRTW,SSCALE,T,VALPCV,VALPHA,VDONE,VK1Y1,WORK,
     4 Y,YLYFIT)
      DOUBLE PRECISION PRECIS, RANGE
      DOUBLE PRECISION A, AA, ABS, AEQ, AINEQ, ALPBES, ALPHA,
     1 ALPOLD, DUB, ONE, PIVOT, RALPFL, REG, RHSNEQ,
     2 S, SOLBES, SOLUTN, SSCALE, VALPCV, VALPHA, VK1Y1, WORK, ZERO
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      LOGICAL LDUM, LBIND, FLAT, PPLTPR, HEADNG, NEWPAG, NOPAGE
      DIMENSION A(MA,MG), T(MY), Y(MY), SQRTW(MY), G(MG), CQUAD(MG),
     1 REG(MREG,MG), AEQ(MEQ,MG), PIVOT(MEQ), VK1Y1(MG), S(MG,3),
     2 AINEQ(MINEQ,MG), VALPHA(MG), VALPCV(MG), RHSNEQ(MINEQ),
     3 WORK(MWORK), IWORK(MA), EXACT(MG), SOLUTN(MG), LBIND(MINEQ),
     4 IISIGN(MG), SOLBES(MG), LSDONE(MDONE,3,2), VDONE(MDONE),
     5 YLYFIT(MY), AA(MG,MG), SSCALE(MG)
      DIMENSION IHOLER(6), PREJ(2), LLSIGN(5), RS2MNX(2)
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
      DATA IHOLER/1HA, 1HN, 1HA, 1HL, 1HY, 1HZ/, RALPHA/1./
      ABS(ALPHA)=DABS(ALPHA)
      SINGLE(ONE)=SNGL(ONE)
C     SINGLE(VAR)=VAR!SP
C     ZERO=0.E0!SP
      ZERO=0.D0
C     ONE=1.E0!SP
      ONE=1.D0
      NGLE=NGL-NEQ
C-----------------------------------------------------------------------
C  PUT SCALE FACTORS FOR SOLUTION IN SSCALE AND SCALE INEQUALITY
C      CONSTRAINTS.
C-----------------------------------------------------------------------
      MG1=MG+1
      MG2=MG1+MG
      MG3=MG2+MG
      CALL SETSCA (WORK,WORK(MG1),WORK(MG2),WORK(MG3),
     1 AINEQ,CQUAD,G,ISTAGE,MG,MINEQ,MREG,MY,NGLE,REG,S,SQRTW,SSCALE,T,
     2 Y)
C-----------------------------------------------------------------------
C  DO SEQUENTIAL HOUSEHOLDER TRANSFORMATIONS TO COMPRESS
C     COEFFICIENT MATRIX INTO AN UPPER TRIANGLE.
C-----------------------------------------------------------------------
      CALL SEQACC (
     1 A,CQUAD,G,IUNIT,IWT,MA,MG,NG,NGL,NGLP1,NLINF,NY,
     2 RANGE,SQRTW,SSCALE,T,Y)
      NGLY=MIN0(NGL,NY)
C-----------------------------------------------------------------------
C  SET UP REGULARIZOR.
C-----------------------------------------------------------------------
      CALL SETREG (MG,MREG,NENDZ,NG,NGL,NGLE,NGLP1,NORDER,
     1 NOUT,NREG,REG,SSCALE)
      IF (NEQ .LE. 0) GO TO 200
C-----------------------------------------------------------------------
C  SET EQUALITY CONSTRAINTS IN USER-SUPPLIED PROGRAM USEREQ AND THEN
C      SCALE THEM AND NORMALIZE THEIR ROWS (IN THE L1 METRIC).
C-----------------------------------------------------------------------
      CALL USEREQ (AEQ,CQUAD,MEQ,MG)
      DO 150 ICOL=1,NGL
        DO 160 IROW=1,NEQ
          AEQ(IROW,ICOL)=AEQ(IROW,ICOL)*SSCALE(ICOL)
  160   CONTINUE
  150 CONTINUE
      DO 170 IROW=1,NEQ
        DUB=ZERO
        DO 180 ICOL=1,NGL
          DUB=DUB+ABS(AEQ(IROW,ICOL))
  180   CONTINUE
        IF (DUB .LE. ZERO) CALL ERRMES (0,.TRUE.,IHOLER,NOUT)
        DUB=ONE/DUB
        DO 190 ICOL=1,NGLP1
          AEQ(IROW,ICOL)=AEQ(IROW,ICOL)*DUB
  190   CONTINUE
  170 CONTINUE
C-----------------------------------------------------------------------
C  ELIMINATE EQUALITY CONSTRAINTS USING A BASIS OF NULL SPACE OF AEQ.
C-----------------------------------------------------------------------
  200 CALL ELIMEQ (AEQ,MEQ,MG,PIVOT,NEQ,NGL,A,MA,REG,MREG,NREG,NGLP1,
     1 NGLY,VK1Y1,RANGE)
C-----------------------------------------------------------------------
C  DO SINGULAR VALUE DECOMPOSITION AND DIAGONALIZATION OF REGULARIZOR.
C-----------------------------------------------------------------------
      CALL SVDRS2 (REG(1,NEQ+1),MREG,NREG,NGLE,REG(1,NGLP1),MREG,
     1 1,S,IERROR,RANGE)
      IF (IERROR .NE. 1) CALL ERRMES (1,.TRUE.,IHOLER,NOUT)
      CALL DIAREG (A,AEQ,MA,MEQ,MG,MREG,NEQ,NGL,NGLE,NGLY,NOUT,
     1 NUNREG,PIVOT,PRECIS,RANGE,REG,S)
C-----------------------------------------------------------------------
C  DO SINGULAR VALUE DECOMPOSITION AND DIAGONALIZATION OF MODIFIED
C     COMPRESSED COEFFICIENT MATRIX A.
C-----------------------------------------------------------------------
      CALL SVDRS2 (A,MA,NGLY,NGLE,A(1,NGLP1),MA,1,S,IERROR,RANGE)
      IF (IERROR .NE. 1) CALL ERRMES (2,.TRUE.,IHOLER,NOUT)
      CALL DIAGA (A,MA,MG,MREG,NEQ,NGL,NGLE,NGLP1,NGLY,REG,S)
      DO 320 J=1,NGLE
        YLYFIT(J)=S(J,1)
  320 CONTINUE
 5320 FORMAT (/16H SINGULAR VALUES/(1X,1P,10E13.3))
      WRITE (33,5320) (YLYFIT(J),J=1,NGLE)
C-----------------------------------------------------------------------
C  LEFT MULTIPLY BY INEQUALITY MATRIX.
C-----------------------------------------------------------------------
      IF (NINEQ .GT. 0) CALL SETGA1 (NINEQ,
     1 A,AINEQ,MA,MG,MINEQ,MREG,NGL,NGLE,REG)
      IF (MAX0(NQPROG(1),NQPROG(2)).LE.0 .AND. ALPST(ISTAGE).LE.0.) CALL
     1 ERRMES (3,.TRUE.,IHOLER,NOUT)
      RSVM2J=SRANGE
      IF (DFMIN.LT.0. .OR. DFMIN+FLOAT(NUNREG).GE.FLOAT(NGLE)) GO TO 390
C-----------------------------------------------------------------------
C  GUARANTEE AT LEAST NUNREG+DFMIN DEGREES OF FREEDOM (IGNORING
C      INEQUALITY CONSTRAINTS) BY USING RSVM2J INSTEAD OF RSVMNX(2,J),
C      IF NECESSARY.
C-----------------------------------------------------------------------
      ALP2=S(1,1)**2
      DO 350 J=1,500
        IF (ALP2 .LE. 0.) GO TO 390
        DF=0.
        DO 360 K=1,NGLE
          DUM=S(K,1)**2
          DF=DF+DUM/(DUM+ALP2)
  360   CONTINUE
        IF (DF .GT. DFMIN+FLOAT(NUNREG)) GO TO 370
        ALP2=ALP2*.1
  350 CONTINUE
  370 RSVM2J=SQRT(10.*ALP2)/S(1,1)
  390 BTEST=SRANGE
      ALPBES=ZERO
      VARZ=SRANGE
      RS2MNX(1)=-1.
      RS2MNX(2)=-1.
C-----------------------------------------------------------------------
C  START OF NQPROG(1) REGULARIZED SOLUTIONS
C-----------------------------------------------------------------------
      LDUM=.TRUE.
      PPLTPR=MAX0(IPRINT(ISTAGE),IUSROU(ISTAGE)) .GE. 3
      NOPAGE=.NOT.PPLTPR
      LHEDNG=0
      IF (NOPAGE) LHEDNG=4
      K=NQPROG(1)
      IF (K .LE. 1) GO TO 410
      RTOT=AMIN1(RSVM2J,RSVMNX(2,1))/(RSVMNX(1,1)*PRECIS)
      IF (RTOT .LE. 1.) RTOT=RSVMNX(2,1)/(RSVMNX(1,1)*PRECIS)
      IF (RTOT .LE. 1.) CALL ERRMES (4,.TRUE.,IHOLER,NOUT)
      RALPHA=RTOT**(1./FLOAT(K-1))
  410 ALPHA=RSVMNX(1,1)*PRECIS*S(1,1)
      DO 420 J=1,K
          CALL SETVAL (ALPHA,LDUM,NINEQ,
     1  A,AINEQ,MA,MG,MINEQ,MREG,NGL,NGLE,REG,RHSNEQ,S,VALPCV,VALPHA,
     2  VK1Y1)
          NEWPAG=MAX0(IPRINT(ISTAGE),IUSROU(ISTAGE),
     1    IPLRES(ISTAGE)+1).GE.4 .OR. LDUM
          HEADNG=PPLTPR .OR. LDUM .OR.
     1    MAX0(IPLRES(ISTAGE),IPLFIT(ISTAGE)).GE.3
          CALL LDPETC (3,.TRUE.,NINEQ,.TRUE.,ICRIT(ISTAGE),DOMOM,PPLTPR,
     1  .TRUE.,ALPHA,HEADNG,NEWPAG,ALPBES,VAR,
     2  A,AA,AINEQ,BTEST,CQUAD,DEGFRE,DEGFRZ,EXACT,G,IERROR,
     3  ISTAGE,IWORK,LBIND,MA,MG,MINEQ,MREG,MWORK,MY,
     4  NGLE,NGLY,PREJ,REG,RHSNEQ,RS2MNX,S,SOLBES,
     5  SOLUTN,SQRTW,SSCALE,T,VALPCV,VALPHA,VARREG,VARZ,WORK,Y,YLYFIT)
          IF (IERROR.EQ.1) CALL RUNRES (3,SOLUTN,.FALSE.,
     A SINGLE(ALPHA/S(1,1)),NOPAGE,
     1 CQUAD,G,IPLFIT,IPLRES,ISTAGE,ITITLE,IUNIT,IWT,LINEPG-LHEDNG,
     2 MWORK,NG,NGL,NLINF,NOUT,NY,SQRTW,SRANGE,SSCALE,T,WORK,Y,YLYFIT)
          ALPHA=ALPHA*RALPHA
          LDUM=.FALSE.
  420 CONTINUE
C-----------------------------------------------------------------------
C  START OF NQPROG(2) REGULARIZED SOLUTIONS.
C-----------------------------------------------------------------------
  450 IF (ALPST(ISTAGE) .LE. 0.) GO TO 455
      K=1
      ALPHA=ALPST(ISTAGE)
      BTEST=SRANGE
      GO TO 475
  455 IF (NQPROG(2) .LE. 0) GO TO 490
      K=NQPROG(2)
      IF (AMIN1(RSVMNX(1,2),RSVMNX(2,2)) .LE. 0.) GO TO 465
      ALPHA=RSVMNX(1,2)*PRECIS*S(1,1)
      IF (K .LE. 1) GO TO 475
      RTOT=AMIN1(RSVM2J,RSVMNX(2,2))/(RSVMNX(1,2)*PRECIS)
      IF (RTOT .LE. 1.) RTOT=RSVMNX(2,2)/(RSVMNX(1,2)*PRECIS)
      IF (RTOT .LE. 1.) CALL ERRMES (4,.TRUE.,IHOLER,NOUT)
      RALPHA=RTOT**(1./FLOAT(K-1))
      GO TO 475
  465 NABUT=2
      IF (RS2MNX(1) .GT. 0.) NABUT=NABUT-1
      IF (RS2MNX(2) .GT. 0.) NABUT=NABUT-1
      L=K-NABUT+1
      IF (L .LE. 0) GO TO 470
      RTOT=ABS(AMIN1(RSVM2J,RS2MNX(2))/(RS2MNX(1)*PRECIS))
      IF (RTOT .LE. 1.) RTOT=ABS(RS2MNX(2)/(RS2MNX(1)*PRECIS))
      RALPHA=RTOT**(1./FLOAT(L))
      IF (RS2MNX(1) .GT. 0.) RS2MNX(1)=RS2MNX(1)*RALPHA
  470 ALPHA=ABS(RS2MNX(1)*PRECIS)*S(1,1)
  475 DO 480 J=1,K
          CALL SETVAL (ALPHA,LDUM,NINEQ,
     1  A,AINEQ,MA,MG,MINEQ,MREG,NGL,NGLE,REG,RHSNEQ,S,VALPCV,VALPHA,
     2  VK1Y1)
          NEWPAG=MAX0(IPRINT(ISTAGE),IUSROU(ISTAGE),
     1    IPLRES(ISTAGE)+1).GE.4 .OR. LDUM
          HEADNG=PPLTPR .OR. LDUM .OR.
     1    MAX0(IPLRES(ISTAGE),IPLFIT(ISTAGE)).GE.3
          CALL LDPETC (3,.TRUE.,NINEQ,.TRUE.,ICRIT(ISTAGE),DOMOM,PPLTPR,
     1  .TRUE.,ALPHA,HEADNG,NEWPAG,ALPBES,VAR,
     2  A,AA,AINEQ,BTEST,CQUAD,DEGFRE,DEGFRZ,EXACT,G,IERROR,
     3  ISTAGE,IWORK,LBIND,MA,MG,MINEQ,MREG,MWORK,MY,
     4  NGLE,NGLY,PREJ,REG,RHSNEQ,RS2MNX,S,SOLBES,
     5  SOLUTN,SQRTW,SSCALE,T,VALPCV,VALPHA,VARREG,VARZ,WORK,Y,YLYFIT)
          IF (IERROR.EQ.1) CALL RUNRES (3,SOLUTN,.FALSE.,
     A SINGLE(ALPHA/S(1,1)),NOPAGE,
     1 CQUAD,G,IPLFIT,IPLRES,ISTAGE,ITITLE,IUNIT,IWT,LINEPG-LHEDNG,
     2 MWORK,NG,NGL,NLINF,NOUT,NY,SQRTW,SRANGE,SSCALE,T,WORK,Y,YLYFIT)
          ALPHA=ALPHA*RALPHA
          LDUM=.FALSE.
  480 CONTINUE
  490 IF (BTEST .GE. SRANGE) CALL ERRMES (5,.TRUE.,IHOLER,NOUT)
      IF (NNSGN(ISTAGE) .LE. 0) GO TO 700
C-----------------------------------------------------------------------
C  START PEAK-CONSTRAINED SOLUTION BY SETTING UP NEW INEQUALITY
C     MATRIX IN AINEQ AND INITIALIZING SO THAT UNSCALED SOLUTION IS
C     MONOTONICALLY DECREASING.
C-----------------------------------------------------------------------
      NGM1=NG-1
      NNINEQ=NINEQ-1
      IF (NONNEG) GO TO 510
      NNINEQ=NINEQ+NGM1
      IF (NNINEQ .LE. MINEQ) GO TO 510
      CALL ERRMES (6,.FALSE.,IHOLER,NOUT)
      GO TO 790
  510 IROW=NNINEQ-NGM1
      DO 520 J=1,NGM1
       IROW=IROW+1
       DO 525 ICOL=1,NGLP1
         AINEQ(IROW,ICOL)=ZERO
  525  CONTINUE
       AINEQ(IROW,J)=ONE*SSCALE(J)
       AINEQ(IROW,J+1)=-ONE*SSCALE(J+1)
       IISIGN(J)=1
  520 CONTINUE
      CALL SETGA1 (NNINEQ,
     1 A,AINEQ,MA,MG,MINEQ,MREG,NGL,NGLE,REG)
      NNSGNI=MIN0(NNSGN(ISTAGE),4)
      ALPOLD=ZERO
      IF (ISTAGE .EQ. 1) BTEST=SRANGE
C-----------------------------------------------------------------------
C  START LOOP TO DO NNSGN(ISTAGE) DIFFERENT PEAK-CONSTRAINED
C     ANALYSES.
C-----------------------------------------------------------------------
      DO 600 INSGN=1,NNSGNI
       NSGNI=NSGN(INSGN)
       LNINEQ=NNINEQ
       IF (NONNEG) LNINEQ=LNINEQ+(NSGNI-(1+LSIGN(1,INSGN))/2)/2+1
       IF (LNINEQ .LE. MINEQ) GO TO 610
       CALL ERRMES (7,.FALSE.,IHOLER,NOUT)
       GO TO 790
C-----------------------------------------------------------------------
C  NNQUSR = NO. OF USER-SUPPLIED INEQUALITIES.
C     (NNQUSR+1 = STARTING ROW OF PEAK CONSTRAINTS IN AINEQ.)
C  NINEQ=NO. OF INEQUALITY CONSTRAINTS IN PREVIOUS PARTS OF PROGRAM
C      WITHOUT PEAK CONSTRAINTS (= NO. OF USER-SUPPLIED CONSTRAINTS +
C      NONNEGATIVITY CONSTRAINTS).
C  NNINEQ = TOTAL NO. OF INEQUALITY CONSTRAINTS INCLUDING MONOTONICITY
C      CONSTRAINTS BUT NOT NONNEGATIVITY CONSTRAINTS AT MINIMA.
C  LNINEQ = TOTAL NO. OF INEQUALITY CONSTRAINTS.
C-----------------------------------------------------------------------
  610  NNQUSR=NINEQ
       IF (NONNEG) NNQUSR=NNQUSR-NG
       RALPFL=ONE
       IF (MAX0(NQPROG(1),NQPROG(2)) .GT. 1) RALPFL=RALPHA
       ALPHA=ALPBES/RALPFL
       MFLAT=MAX0(1,NFLAT(INSGN,ISTAGE))
       IF (RALPFL .LE. ONE) MFLAT=1
C-----------------------------------------------------------------------
C  START OF LOOP TO DO UP TO MFLAT PEAK-CONSTRAINED ANALYSES
C     UNTIL THERE ARE NO FLAT SPOTS IN THE SOLUTION.
C-----------------------------------------------------------------------
       DO 620 JFLAT=1,MFLAT
         ALPHA=ALPHA*RALPFL
         IF (ABS(ALPOLD/ALPHA-ONE) .LE. 1.E3*PRECIS) GO TO 630
         ALPOLD=ALPHA
         LDUM=INSGN.EQ.1 .AND. JFLAT.EQ.1
         CALL SETVAL (ALPHA,LDUM,NNINEQ,
     1  A,AINEQ,MA,MG,MINEQ,MREG,NGL,NGLE,REG,RHSNEQ,S,VALPCV,VALPHA,
     2  VK1Y1)
  630    J=INSGN
         CALL SETSGN (J,NSGNI,LSIGN,NOUT,LLSIGN,NG,SOLBES,SRANGE)
C-----------------------------------------------------------------------
C  DO COMPLETE PEAK-CONSTRAINED SOLUTION.
C-----------------------------------------------------------------------
         CALL ANPEAK (LNINEQ,
     1    A,AA,AINEQ,ALPHA,BTEST,CQUAD,DEGFRZ,EXACT,FLAT,G,IISIGN,
     2    ISTAGE,IWORK,LBIND,LLSIGN,LSDONE,MA,MDONE,MG,MINEQ,
     3    MREG,MWORK,MY,NGLE,NGLY,NNINEQ,NNQUSR,
     4    NSGNI,REG,RHSNEQ,RS2MNX,S,SOLBES,
     5    SOLUTN,SQRTW,SSCALE,T,VALPCV,VALPHA,VARZ,VDONE,WORK,Y,YLYFIT)
         IF (.NOT.FLAT) GO TO 600
  620  CONTINUE
  600 CONTINUE
      IF ((ISTAGE.EQ.2.AND..NOT.DOCHOS) .OR. .NOT.NONNEG) GO TO 700
C-----------------------------------------------------------------------
C  RESTORE ORIGINAL NONNEGATIVITY CONSTRAINTS.
C-----------------------------------------------------------------------
      NINEQ=NINEQ-NG
      CALL SETNNG (AINEQ,MINEQ,NG,NGLP1,NINEQ)
  700 IF (IPLRES(ISTAGE).NE.2 .AND. IPLFIT(ISTAGE).NE.2) GO TO 710
C-----------------------------------------------------------------------
C  FOR CHOSEN SOLUTION, PLOT RESIDUALS AND FIT AND REPEAT THE
C      SOLUTION FOR OUTPUT AT END OF THE RUN.
C-----------------------------------------------------------------------
 5700 FORMAT (22H1CONTIN 2DP (AUG 82) (,6A1,1H),3X,80A1,4X,
     1 15HCHOSEN SOLUTION)
      WRITE (33,5700) IAPACK,ITITLE
      CALL RUNRES (2,SOLBES,.FALSE.,SINGLE(ALPBES/S(1,1)),.TRUE.,
     1 CQUAD,G,IPLFIT,IPLRES,ISTAGE,ITITLE,IUNIT,IWT,LINEPG,MWORK,NG,
     2 NGL,NLINF,NOUT,NY,SQRTW,SRANGE,SSCALE,T,WORK,Y,YLYFIT)
  710 IF (ISTAGE.EQ.1 .OR. .NOT.DOCHOS .OR.
     1 MAX0(IPRINT(2),IUSROU(2)).LT.2) GO TO 800
      LDUM=NONNEG .AND. NNSGN(ISTAGE).GT.0
      IF (LDUM) CALL SETGA1 (NINEQ,
     1 A,AINEQ,MA,MG,MINEQ,MREG,NGL,NGLE,REG)
      CALL SETVAL (ALPBES,LDUM,NINEQ,
     1  A,AINEQ,MA,MG,MINEQ,MREG,NGL,NGLE,REG,RHSNEQ,S,VALPCV,VALPHA,
     2  VK1Y1)
 5710 FORMAT (32H1CONTIN VERSION 2DP (AUG 1982) (,6A1,
     1 11H PACKAGE)  ,16(2H++),19H  CHOSEN SOLUTION  ,16(2H++))
      WRITE (33,5710) IAPACK
      CALL LDPETC (2,.FALSE.,NINEQ,.FALSE.,1,DOMOM,.TRUE.,
     1 .TRUE.,ALPBES,.TRUE.,.FALSE.,ALPBES,VAR,
     2  A,AA,AINEQ,BTEST,CQUAD,DEGFRE,DEGFRZ,EXACT,G,IERROR,
     3  ISTAGE,IWORK,LBIND,MA,MG,MINEQ,MREG,MWORK,MY,
     4  NGLE,NGLY,PREJ,REG,RHSNEQ,RS2MNX,S,SOLBES,
     5  SOLUTN,SQRTW,SSCALE,T,VALPCV,VALPHA,VARREG,VARZ,WORK,Y,YLYFIT)
  790 IF (ISTAGE .NE. 2) STOP
  800 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE ANPEAK.  DOES ONE COMPLETE PEAK-CONSTRAINED ANALYSIS
C      AND PLOTS AND PRINTS SOLUTION, AS WELL AS PRINTING ONE LINE
C      OF INTERMEDIATE OUTPUT PER ITERATION.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - UPDSGN, ERRMES, LDPETC, UPDDON, FFLAT, UPDLLS,
C      RUNRES
C  WHICH IN TURN CALL - LDP, CVNEQ, FISHNI, BETAIN, GAMLN, NNLS,
C      DIFF, H12, G1, G2, ELIMEQ, SVDRS2, LH1405, QRBD,
C      GETYLY, GETROW, USERK, USERLF, PLPRIN, USEROU, MOMENT, MOMOUT,
C      GETPRU, PLRES, PGAUSS, USERTR
C-----------------------------------------------------------------------
      SUBROUTINE ANPEAK (LNINEQ,
     1    A,AA,AINEQ,ALPHA,BTEST,CQUAD,DEGFRZ,EXACT,FLAT,G,IISIGN,
     2    ISTAGE,IWORK,LBIND,LLSIGN,LSDONE,MA,MDONE,MG,MINEQ,
     3    MREG,MWORK,MY,NGLE,NGLY,NNINEQ,NNQUSR,
     4    NSGNI,REG,RHSNEQ,RS2MNX,S,SOLBES,
     5    SOLUTN,SQRTW,SSCALE,T,VALPCV,VALPHA,VARZ,VDONE,WORK,Y,YLYFIT)
      DOUBLE PRECISION PRECIS, RANGE
      DOUBLE PRECISION A, AA, AINEQ, ALPHA, DUB, REG, RHSNEQ, S,
     1 SOLBES, SOLUTN, SSCALE, VALPCV, VALPHA, WORK
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      LOGICAL DONE, FLAT, LDUM, LBIND, FFLAT, PPLTPR
      DIMENSION S(MG,3), LLSIGN(5), LSDONE(MDONE,3,2), VDONE(MDONE),
     1 A(MA,MG), REG(MREG,MG), RHSNEQ(MINEQ), VALPHA(MG), IISIGN(MG),
     2 AINEQ(MINEQ,MG), WORK(MWORK), IWORK(MA), VALPCV(MG),
     3 G(MG), EXACT(MG), CQUAD(MG), SOLUTN(MG),
     4 LBIND(MINEQ), AA(MG,MG), SOLBES(MG),
     5 SQRTW(MY), T(MY), Y(MY), YLYFIT(MY), SSCALE(MG), RS2MNX(2)
      DIMENSION IHOLER(6), ISTAR(4), JSTAGE(4), INC(4), PREJ(2),
     1 VARTRY(4), LLSTRY(5,4), LLSBES(5)
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
      DATA IHOLER/1HA, 1HN, 1HP, 1HE, 1HA, 1HK/,
     1 ISTAR/1H , 1H*, 1HX, 1HF/
      NSGNM1=NSGNI-1
      DONE=.FALSE.
      FLAT=.FALSE.
      NDONE=0
      NQPITR=0
      ITER=0
      VARRBS=SRANGE
      DUB=0.
      DO 110 J=1,NSGNI
        JSTAGE(J)=0
        INC(J)=1
  110 CONTINUE
 5200 FORMAT (1H1,I15,29H-EXTREMA-CONSTRAINED ANALYSIS/
     1 8H0ALPHA =,1PE9.2,5X,12HALPHA/S(1) =,E9.2/
     2 6H0ITER.,6X,10HOBJ. FCTN.,8X,8HVARIANCE,7X,
     3 9HSTD. DEV.,3X,11HDEG FREEDOM,3X,9HPROB1 REJ,3X,9HPROB2 REJ,10X,
     4 15HEXTREMA INDICES)
      DUM=ALPHA/S(1,1)
      DDUM=ALPHA
      WRITE (33,5200) NSGNM1,DDUM,DUM
C-----------------------------------------------------------------------
C  START OF MAIN LOOP FOR SEARCHING FOR OPTIMUM SET OF EXTREMA.
C-----------------------------------------------------------------------
  200 ITER=ITER+1
      IF (NDONE .LE. 0) GO TO 230
C-----------------------------------------------------------------------
C  CHECK TO SEE IF THESE EXTREMA ARE ALREADY INCLUDED IN A
C      PREVIOUS SOLUTION.
C-----------------------------------------------------------------------
      DO 210 K=1,NDONE
        DO 220 J=1,NSGNM1
          L=IABS(LLSIGN(J+1))
          LL=LSDONE(K,J,1)
          IF ((LL.LE.0 .AND. L.NE.-LL)  .OR.
     1    (LL.GT.0 .AND. L.LT.LL)) GO TO 210
          LL=LSDONE(K,J,2)
          IF ((LL.LE.0 .AND. L.NE.-LL)  .OR.
     1    (LL.GT.0 .AND. L.GT.LL)) GO TO 210
  220   CONTINUE
        LSTAR=3
        VARREG=VDONE(K)
        GO TO 320
  210 CONTINUE
C-----------------------------------------------------------------------
C  UPDATE SIGNS OF INEQUALITY MATRIX, RIGHT-HAND SIDE, AND
C      IISIGN(J) (MONOTONICITY INDICATOR FOR J-TH GRID POINT).
C-----------------------------------------------------------------------
  230 CALL UPDSGN (NSGNI,LLSIGN,
     1 A,AINEQ,IISIGN,MA,MG,MINEQ,MREG,NGLE,NGLP1,NNINEQ,
     2 NNQUSR,NONNEG,NOUT,REG,RHSNEQ,S,VALPHA)
      NQPITR=NQPITR+1
      IF (NQPITR .LE. MQPITR) GO TO 235
      CALL ERRMES (1,.FALSE.,IHOLER,NOUT)
      GO TO 790
  235 LDUM=ISTAGE .EQ. 1
C-----------------------------------------------------------------------
C  DO CONSTRAINED SOLUTION.
C-----------------------------------------------------------------------
      CALL LDPETC (5,.FALSE.,LNINEQ,LDUM,ICRIT(ISTAGE),.FALSE.,.FALSE.,
     1 .FALSE.,ALPHA,.FALSE.,.FALSE.,DUB,VAR,
     2  A,AA,AINEQ,BTEST,CQUAD,DEGFRE,DEGFRZ,EXACT,G,IERROR,
     3  ISTAGE,IWORK,LBIND,MA,MG,MINEQ,MREG,MWORK,MY,
     4  NGLE,NGLY,PREJ,REG,RHSNEQ,RS2MNX,S,SOLBES,
     5  SOLUTN,SQRTW,SSCALE,T,VALPCV,VALPHA,VARREG,VARZ,WORK,Y,YLYFIT)
      IF (IERROR .EQ. 1) GO TO 240
      LSTAR=4
      VARREG=SRANGE
      GO TO 320
  240 NDONE=NDONE+1
      IF (NDONE .LE. MDONE) GO TO 250
      CALL ERRMES (2,.FALSE.,IHOLER,NOUT)
      GO TO 790
C-----------------------------------------------------------------------
C  UPDATE LSDONE (EXTREMA RANGES COVERED BY PREVIOUS SOLUTIONS),
C      AND IF THIS SOLUTION IS IDENTICAL WITH A PRECEDING ONE,
C      REPLACE VARREG WITH THE PRECEDING ONE.
C-----------------------------------------------------------------------
  250 CALL UPDDON (
     1 NSGNM1,LLSIGN,LSDONE,MDONE,NDONE,NNQUSR,LBIND,MINEQ,
     2 NG,VARREG,VDONE)
      LSTAR=1
      IF (VARREG .GE. VARRBS) GO TO 320
C-----------------------------------------------------------------------
C  STORE BEST EXTREMA SO FAR IN LLSBES.
C-----------------------------------------------------------------------
      LSTAR=2
      VARRBS=VARREG
      L=NSGNI+1
      DO 310 J=1,L
        LLSBES(J)=LLSIGN(J)
  310 CONTINUE
      FLAT=FFLAT (NSGNI,NONNEG,NG,SOLUTN,SRMIN,NNQUSR,LBIND,
     1 MINEQ,LLSIGN)
C-----------------------------------------------------------------------
C  OUTPUT RESULTS OF ITERATION ITER.
C-----------------------------------------------------------------------
 5320 FORMAT (1X,A1,I4,1PE16.6,E16.5,E16.3,0PF14.3,2F12.3,8X,5I5)
  320 DUM=SRANGE
      DDUM=FLOAT(NY)-DEGFRE
      IF (LSTAR.LE.2 .AND. DDUM.GT.0.) DUM=SQRT(VAR/DDUM)
      IF (LSTAR .LE. 2) WRITE (33,5320) ISTAR(LSTAR),ITER,VARREG,VAR,
     1 DUM,DEGFRE,PREJ,(LLSIGN(J),J=1,NSGNI)
 5322 FORMAT (1X,A1,I4,1PE16.6,78X,5I5)
      IF (LSTAR .GE. 3) WRITE (33,5322) ISTAR(LSTAR),ITER,VARREG,
     1 (LLSIGN(J),J=1,NSGNI)
C-----------------------------------------------------------------------
C  UPDATE POSITIONS OF EXTREMA.
C-----------------------------------------------------------------------
      CALL UPDLLS (NSGNI,JSTAGE,NOUT,VARTRY,VARREG,LLSTRY,LLSIGN,
     1 INC,DONE)
C-----------------------------------------------------------------------
C  IF NOT DONE, THEN START ANOTHER ITERATION.
C-----------------------------------------------------------------------
      IF (.NOT.DONE) GO TO 200
C-----------------------------------------------------------------------
C  REPEAT BEST SOLUTION FOR OUTPUT AT END OF PEAK-CONSTRAINED ANALYSIS.
C-----------------------------------------------------------------------
      CALL UPDSGN (NSGNI,LLSBES,
     1 A,AINEQ,IISIGN,MA,MG,MINEQ,MREG,NGLE,NGLP1,NNINEQ,
     2 NNQUSR,NONNEG,NOUT,REG,RHSNEQ,S,VALPHA)
      PPLTPR=MAX0(IPRINT(ISTAGE),IUSROU(ISTAGE)) .GE. 1
      CALL LDPETC (1,.FALSE.,LNINEQ,.FALSE.,ICRIT(ISTAGE),DOMOM,PPLTPR,
     1 .TRUE.,ALPHA,.TRUE.,.FALSE.,DUB,VAR,
     2  A,AA,AINEQ,BTEST,CQUAD,DEGFRE,DEGFRZ,EXACT,G,IERROR,
     3  ISTAGE,IWORK,LBIND,MA,MG,MINEQ,MREG,MWORK,MY,
     4  NGLE,NGLY,PREJ,REG,RHSNEQ,RS2MNX,S,SOLBES,
     5  SOLUTN,SQRTW,SSCALE,T,VALPCV,VALPHA,VARREG,VARZ,WORK,Y,YLYFIT)
      DUM=ALPHA/S(1,1)
      CALL RUNRES (1,SOLUTN,.FALSE.,DUM,.FALSE.,
     1 CQUAD,G,IPLFIT,IPLRES,ISTAGE,ITITLE,IUNIT,IWT,LINEPG,MWORK,NG,
     2 NGL,NLINF,NOUT,NY,SQRTW,SRANGE,SSCALE,T,WORK,Y,YLYFIT)
      GO TO 795
  790 FLAT=.FALSE.
C-----------------------------------------------------------------------
C  RESTORE INEQUALITY CONSTRAINTS TO ORIGINAL MONOTONICALLY
C      DECREASING CONDITION.
C-----------------------------------------------------------------------
  795 LLSTRY(1,1)=1
      LLSTRY(2,1)=NG
      CALL UPDSGN (1,LLSTRY,
     1 A,AINEQ,IISIGN,MA,MG,MINEQ,MREG,NGLE,NGLP1,NNINEQ,
     2 NNQUSR,NONNEG,NOUT,REG,RHSNEQ,S,VALPHA)
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  FUNCTION BETAIN.  APPROXIMATES THE INCOMPLETE BETA FUNCTION RATIO
C      I(SUB X)(A,B) USING ABRAMOWITZ AND STEGUN (26.5.5).
C  GOOD TO ABOUT 1 PART IN TOL (TOL SET IN DATA STATEMENT BELOW).
C  FOR VERY LARGE (.GT. 1.E+4) A OR B, OF THE ORDER OF MAX(A,B) TERMS
C      ARE NEEDED, AND AN ASYMPTOTIC FORMULA WOULD BE BETTER.
C      TAKES AN ERROR EXIT IF A OR B .GE. 2.E+4.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - ERRMES, GAMLN
C-----------------------------------------------------------------------
      FUNCTION BETAIN (X,A,B,NOUT)
      LOGICAL SWAP
      DIMENSION IHOLER(6)
      DATA IHOLER/1HB, 1HE, 1HT, 1HA, 1HI, 1HN/, TOL/1.E-5/
      IF (X.LT.0. .OR. X.GT.1. .OR. AMIN1(A,B).LE.0. .OR.
     1 AMAX1(A,B).GE.2.E+4) CALL ERRMES (1,.TRUE.,IHOLER,NOUT)
      BETAIN=X
      IF (X.LE.0. .OR. X.GE.1.) RETURN
      SWAP=X .GT. .5
      IF (SWAP) GO TO 150
      XX=X
      AA=A
      BB=B
      GO TO 200
C-----------------------------------------------------------------------
C      WHEN SWAP=.TRUE., I(SUB 1-X)(B,A)=1-I(SUB X)(A,B) IS EVALUATED
C      FIRST.
C-----------------------------------------------------------------------
  150 XX=1.-X
      AA=B
      BB=A
  200 CX=1.-XX
      R=XX/CX
C-----------------------------------------------------------------------
C  TERM IMAX IS APPROXIMATELY THE MAXIMUM TERM IN THE SUM.
C-----------------------------------------------------------------------
      IMAX=MAX0(0,INT((R*BB-AA-1.)/(R+1.)))
      RI=FLOAT(IMAX)
      SUM=0.
      TERMAX=(AA+RI)*ALOG(XX)+(BB-RI-1.)*ALOG(CX)+GAMLN(AA+BB)-
     1 GAMLN(AA+RI+1.)-GAMLN(BB-RI)
      IF (TERMAX .LT. -50.) GO TO 700
      TERMAX=EXP(TERMAX)
      TERM=TERMAX
      SUM=TERM
C-----------------------------------------------------------------------
C  SUM TERMS FOR I=IMAX+1,IMAX+2,... UNTIL CONVERGENCE.
C-----------------------------------------------------------------------
      I1=IMAX+1
      DO 250 I=I1,20000
        RI=FLOAT(I)
        TERM=TERM*R*(BB-RI)/(AA+RI)
        SUM=SUM+TERM
        IF (ABS(TERM) .LE. TOL*SUM) GO TO 300
  250 CONTINUE
      CALL ERRMES (2,.TRUE.,IHOLER,NOUT)
  300 IF (IMAX .EQ. 0) GO TO 700
C-----------------------------------------------------------------------
C  SUM TERMS FOR I=IMAX-1,IMAX-2,... UNTIL CONVERGENCE.
C-----------------------------------------------------------------------
      TERM=TERMAX
      RI=FLOAT(IMAX)
      DO 320 I=1,IMAX
        TERM=TERM*(AA+RI)/(R*(BB-RI))
        SUM=SUM+TERM
        IF (ABS(TERM) .LE. TOL*SUM) GO TO 700
        RI=RI-1.
  320 CONTINUE
  700 BETAIN=SUM
      IF (SWAP) BETAIN=1.-BETAIN
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE CQTRAP.  GIVEN QUADRATURE GRID G, STORES WEIGHTS FOR
C      TRAPEZOIDAL RULE IN CQUAD(J), J=1,NG.
      SUBROUTINE CQTRAP (G,CQUAD,NG)
      DIMENSION G(NG), CQUAD(NG)
      JJ=NG-1
      DELOLD=0.
      DO 110 J=1,JJ
        DEL=.5*(G(J+1)-G(J))
        CQUAD(J)=DEL+DELOLD
        DELOLD=DEL
  110 CONTINUE
      CQUAD(NG)=DELOLD
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE CVNEQ.  ELIMINATES ANY BINDING INEQUALITY CONSTRAINTS
C      AS EQUALITY CONSTRAINTS, AND PUTS DEGREES OF FREEDOM IN DEGFRE.
C      IF PPLTPR=.TRUE., THEN PUTS (SQUARE ROOT OF THE COVARIANCE MATRIX
C      OF THE SCALED SOLUTION)/(STDDEV) IN AA(J,K), J=1,NGL, K=1,NGLY.
C  ON RETURN, IERROR = 1 FOR NORMAL RETURN,
C                      5 FOR ERROR RETURN FROM SVDRS2.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - ERRMES, ELIMEQ, SVDRS2, H12
C  WHICH IN TURN CALL - LH1405, QRBD, G1, G2, DIFF
C-----------------------------------------------------------------------
      SUBROUTINE CVNEQ (ALPHA,IERROR,NNNNEQ,SOLUTN,
     1 A,AA,AINEQ,DEGFRE,LBIND,MA,MG,MINEQ,MREG,MWORK,NGL,NGLE,
     2 NGLP1,NGLY,NOUT,PPLTPR,RANGE,REG,S,VALPCV,WORK)
      DOUBLE PRECISION A, AA, ABS, AINEQ, ALPHA, DUB, RANGE, REG, S,
     1 SOLUTN, VALPCV, WORK, ZERO
      LOGICAL LBIND, PPLTPR, FAIL
      DIMENSION AA(MG,MG), WORK(MWORK), A(MA,MG), S(MG,3), SOLUTN(MG),
     1 AINEQ(MINEQ,MG), VALPCV(MG), REG(MREG,MG), LBIND(MINEQ)
      DIMENSION IHOLER(6)
      DATA IHOLER/1HC, 1HV, 1HN, 1HE, 1HQ, 1H /
      ABS(DUB)=DABS(DUB)
C     ZERO=0.E0!SP
      ZERO=0.D0
      FAIL=.FALSE.
      DEGFRE=0.
      IERROR=1
      NGLEP1=NGLE+1
      IY=NGLEP1*(NNNNEQ+2)
      IW=-NNNNEQ
      NBIND=0
      IF (NNNNEQ .EQ. 0) GO TO 180
      DO 150 IROW=1,NNNNEQ
        IY=IY+1
        LBIND(IROW)=WORK(IY) .GT. ZERO
        IF (.NOT.LBIND(IROW)) GO TO 150
C-----------------------------------------------------------------------
C  IF BINDING INEQUALITY CONSTRAINT ONLY INVOLVES ONE SOLUTION
C      POINT, THEN SET THAT SOLUTION POINT TO THE R.H.S. OF INEQUALITY.
C-----------------------------------------------------------------------
        L=0
        DO 152 ICOL=1,NGL
          IF (ABS(AINEQ(IROW,ICOL)) .LE. ZERO) GO TO 152
          IF (L .NE. 0) GO TO 154
          L=ICOL
  152   CONTINUE
        SOLUTN(L)=AINEQ(IROW,NGLP1)/AINEQ(IROW,L)
C-----------------------------------------------------------------------
C  PUT AUGMENTED MATRIX OF BINDING INEQUALITIES STARTING IN WORK(1)
C      WITH COLUMN INCREMENTS OF NNNNEQ.
C  LHS = D*K2*Z*H1**(-1)*W,  RHS = D(LOWER CASE)-D*VALPCV, WHERE
C      VALPCV = K1*X1+K2*Z*H1**(-1)*R1.
C-----------------------------------------------------------------------
  154   NBIND=NBIND+1
        IW=IW+1
        IIW=IW+NNNNEQ
        DO 160 ICOL=1,NGLE
          WORK(IIW)=A(IROW,ICOL)/S(ICOL,2)
          IIW=IIW+NNNNEQ
  160   CONTINUE
        DUB=AINEQ(IROW,NGLP1)
        DO 170 J=1,NGL
          DUB=DUB-AINEQ(IROW,J)*VALPCV(J)
  170   CONTINUE
        WORK(IIW)=DUB
  150 CONTINUE
      IF (NBIND .LT. NGLE) GO TO 180
      CALL ERRMES (1,.FALSE.,IHOLER,NOUT)
 5180 FORMAT (1X,2I4)
      WRITE (33,5180) NBIND,NGLE
      STOP
C-----------------------------------------------------------------------
C  PUT H IN AA.
C-----------------------------------------------------------------------
  180 DO 190 J=1,NGLY
        DO 195 K=1,NGLE
          AA(J,K)=ZERO
  195   CONTINUE
        AA(J,J)=S(J,1)
        AA(J,NGLEP1)=A(J,NGLP1)-S(J,1)*REG(J,NGLP1)
  190 CONTINUE
C-----------------------------------------------------------------------
C  PUT NEW H*K IN AA.
C-----------------------------------------------------------------------
      NGLEE=NGLE-NBIND
      IF (NBIND .EQ. 0) GO TO 250
      IW=NGLP1*NNNNEQ+1
      IIW=IW+NGL
      CALL ELIMEQ (WORK,NNNNEQ,MG,WORK(IW),NBIND,NGLE,AA,MG,AA,MG,
     1 0,NGLEP1,NGLY,WORK(IIW),RANGE)
C-----------------------------------------------------------------------
C  SAVE S AND THEN DO SVD OF NEW H*K2.  NEW W WILL GO IN COLUMNS
C      (NBIND+1) TO NGLE OF AA.
C-----------------------------------------------------------------------
      DO 191 J=1,NGLE
        AA(J,MG-1)=S(J,1)
        AA(J,MG)=S(J,2)
  191 CONTINUE
      J=NBIND+1
      CALL SVDRS2 (AA(1,J),MG,NGLY,NGLEE,SOLUTN,
     1 MG,0,S,IERROR,RANGE)
      IF (IERROR .EQ. 1) GO TO 250
      CALL ERRMES (2,.FALSE.,IHOLER,NOUT)
      FAIL=.TRUE.
      GO TO 340
  250 DUM=ALPHA**2
      NGLEEY=MIN0(NGLY,NGLEE)
      DO 260 J=1,NGLEEY
        S(J,3)=S(J,1)/(DUM+S(J,1)**2)
        DEGFRE=DEGFRE+S(J,1)*S(J,3)
  260 CONTINUE
  280 IF (NBIND .GT. 0) GO TO 340
C-----------------------------------------------------------------------
C  IF NBIND=0, PUT (SQUARE ROOT OF THE COVARIANCE MATRIX OF THE
C      SCALED SOLUTION)/(STDDEV) IN AA.  IN THIS CASE, THE NEW K2*W
C      IS AN IDENTITY MATRIX.
C-----------------------------------------------------------------------
  310 DO 320 ICOL=1,NGLY
        IF (ICOL .GT. NGLEEY) GO TO 335
        DUB=S(ICOL,3)
        DO 330 IROW=1,NGL
          AA(IROW,ICOL)=DUB*REG(IROW,ICOL)
  330   CONTINUE
        GO TO 320
  335   DO 337 IROW=1,NGL
          AA(IROW,ICOL)=ZERO
  337   CONTINUE
  320 CONTINUE
      GO TO 800
C-----------------------------------------------------------------------
C  RESTORE S.
C-----------------------------------------------------------------------
  340 DO 345 J=1,NGLE
        S(J,1)=AA(J,MG-1)
        S(J,2)=AA(J,MG)
  345 CONTINUE
      IF (.NOT.PPLTPR .OR. FAIL) GO TO 800
C-----------------------------------------------------------------------
C  MOVE NEW W DOWN NBIND ROWS IN AA AND ZERO FIRST NBIND ROWS OF AA FOR
C      CONVENIENT APPLICATION OF H12 FOR CALCULATION OF NEW K2*W.
C-----------------------------------------------------------------------
  350 ICOL=NBIND
      DO 360 J=1,NGLEE
        ICOL=ICOL+1
        IROW=NGLE+1
        DO 370 I=1,NGLEE
          IROW=IROW-1
          IIROW=IROW-NBIND
          AA(IROW,ICOL)=AA(IIROW,ICOL)
  370   CONTINUE
        DO 380 IROW=1,NBIND
          AA(IROW,ICOL)=ZERO
  380   CONTINUE
  360 CONTINUE
C-----------------------------------------------------------------------
C  MULTIPLY W (IN AA) BY K2 (IN WORK).  NEW K2*W IS THEN IN AA(J,K),
C      J=1,NGLE, K=NBIND+1,NGLE.
C-----------------------------------------------------------------------
      I=NBIND
      IIW=IW+NBIND-1
      DO 390 J=1,NBIND
        CALL H12 (2,I,I+1,NGLE,WORK(I),NNNNEQ,WORK(IIW),AA(1,NBIND+1),
     1  1,MG,NGLEE,RANGE)
        I=I-1
        IIW=IIW-1
  390 CONTINUE
C-----------------------------------------------------------------------
C  PUT (SQUARE ROOT OF THE COVARIANCE MATRIX OF THE SCALED SOLUTION)/
C      (STDDEV) IN AA(J,K), J=1,NGL, K=1,NGLY.
C-----------------------------------------------------------------------
      DO 410 ICOL=1,NGLY
        IICOL=ICOL+NBIND
        DO 420 IROW=1,NGL
          AA(IROW,ICOL)=ZERO
          IF (ICOL .GT. NGLEEY) GO TO 420
          DUB=ZERO
          DO 430 J=1,NGLE
            DUB=DUB+REG(IROW,J)*AA(J,IICOL)
  430     CONTINUE
          AA(IROW,ICOL)=DUB*S(ICOL,3)
  420   CONTINUE
  410 CONTINUE
  800 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE DIAGA. PUTS W**(T)*R1 INTO REG(J,NGLP1), J=1,NGLE.
C      PUTS K2*Z*H1**(-1)*W INTO FIRST NGLE ROWS AND COLUMNS OF REG.
C  IF NGLE.LT.NGLY, THEN REG(J,NGLP1) AND S(J,1), J=NGLE+1,NGLY ARE
C      ZEROED.  IF NGLE.GT.NGLY, THEN A(J,NGLP1) AND S(J,1),
C      J=NGLY+1,NGLE ARE ZEROED.
      SUBROUTINE DIAGA (A,MA,MG,MREG,NEQ,NGL,NGLE,NGLP1,NGLY,REG,S)
      DOUBLE PRECISION A, DUM, REG, S, ZERO
      DIMENSION A(MA,MG), REG(MREG,MG), S(MG,3)
C     ZERO=0.E0!SP
      ZERO=0.D0
      IF (NGLY .GE. NGLE) GO TO 150
      K=NGLY+1
      DO 140 J=K,NGLE
        S(J,1)=ZERO
        A(J,NGLP1)=ZERO
  140 CONTINUE
  150 DO 160 IROW=1,NGL
        DO 170 ICOL=1,NGLE
          IICOL=NEQ
          DUM=ZERO
          DO 180 J=1,NGLE
            IICOL=IICOL+1
            DUM=DUM+REG(IROW,IICOL)*A(J,ICOL)
  180     CONTINUE
          S(ICOL,2)=DUM
  170   CONTINUE
        DO 190 ICOL=1,NGLE
          REG(IROW,ICOL)=S(ICOL,2)
  190   CONTINUE
  160 CONTINUE
      DO 210 IROW=1,NGLE
        DUM=ZERO
        DO 220 ICOL=1,NGLE
          DUM=DUM+A(ICOL,IROW)*REG(ICOL,NGLP1)
  220   CONTINUE
        S(IROW,2)=DUM
  210 CONTINUE
      DO 250 IROW=1,NGLE
        REG(IROW,NGLP1)=S(IROW,2)
  250 CONTINUE
      IF (NGLE .GE. NGLY) GO TO 800
      J=NGLE+1
      DO 260 IROW=J,NGLY
        S(IROW,1)=ZERO
        REG(IROW,NGLP1)=ZERO
  260 CONTINUE
  800 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE DIAREG.  CONTINUE DIAGONALIZATION OF REGULARIZOR BY
C      PUTTING C*K2*Z*H1**(-1) IN A AND K2*Z*H1**(-1) IN COLUMNS
C      NEQ+1,...,NGL OF REG.
C  IF NECESSARY, MAKE REGULARIZOR FULL RANK BY MAKING ALL SINGULAR
C      VALUES AT LEAST SQRT(.1*PRECIS)*(LARGEST SINGULAR VALUE).
C  (IF NEQ=0, THEN K2 IS THE NGL-BY-NGL IDENTITY MATRIX.)
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - H12
C-----------------------------------------------------------------------
      SUBROUTINE DIAREG (A,AEQ,MA,MEQ,MG,MREG,NEQ,NGL,NGLE,NGLY,
     1 NOUT,NUNREG,PIVOT,PRECIS,RANGE,REG,S)
      DOUBLE PRECISION A, AEQ, DUM, ONE, PIVOT, PRECIS, RANGE, REG,
     1 S, SMALL, SQRT, ZERO
      DIMENSION S(MG,3), REG(MREG,MG), A(MA,MG), PIVOT(MEQ),
     1 AEQ(MEQ,MG)
      SQRT(ONE)=DSQRT(ONE)
C     ZERO=0.E0!SP
      ZERO=0.D0
C     ONE=1.E0!SP
      ONE=1.D0
      SMALL=SQRT(.1*PRECIS)*S(1,1)
      NUNREG=0
      ICOL=NEQ
      DO 120 J=1,NGLE
        ICOL=ICOL+1
        IF (S(J,1) .GT. SMALL) GO TO 125
        NUNREG=NUNREG+1
        S(J,1)=SMALL
  125   DUM=ONE/S(J,1)
C-----------------------------------------------------------------------
C  MOVE MATRIX Z*H1**(-1) DOWN NEQ ROWS AND ZERO FIRST NEQ ROWS FOR
C      CONVENIENT APPLICATION OF H12 FOR CALCULATING K2*Z*H1**(-1).
C-----------------------------------------------------------------------
        IROW=NGL+1
        DO 130 I=1,NGLE
          IROW=IROW-1
          IIROW=IROW-NEQ
          REG(IROW,ICOL)=REG(IIROW,ICOL)*DUM
  130   CONTINUE
        IF (NEQ .EQ. 0) GO TO 120
        DO 135 I=1,NEQ
          REG(I,ICOL)=ZERO
  135   CONTINUE
  120 CONTINUE
      WRITE (33,5120) NUNREG
 5120 FORMAT (/1X,I3,24H UNREGULARIZED VARIABLES)
C-----------------------------------------------------------------------
C  PUT C*K2*Z*H1**(-1) IN A.
C-----------------------------------------------------------------------
      DO 150 IROW=1,NGLY
        ICOL=NEQ
        DO 155 J=1,NGLE
          ICOL=ICOL+1
          DUM=ZERO
          L=NEQ
          DO 160 K=1,NGLE
            L=L+1
            DUM=DUM+A(IROW,L)*REG(L,ICOL)
  160     CONTINUE
          S(J,1)=DUM
  155   CONTINUE
        DO 165 J=1,NGLE
          A(IROW,J)=S(J,1)
  165   CONTINUE
  150 CONTINUE
      IF (NEQ .EQ. 0) GO TO 800
C-----------------------------------------------------------------------
C  PUT K2*Z*H1**(-1) IN COLUMNS NEQ+1,...,NGL OF REG.  (IF NEQ=0, THEN
C      K2 IS THE IDENTITY MATRIX AND NOTHING IS DONE.)
C-----------------------------------------------------------------------
      I=NEQ
      DO 210 J=1,NEQ
        CALL H12 (2,I,I+1,NGL,AEQ(I,1),MEQ,PIVOT(I),REG(1,NEQ+1),
     1  1,MREG,NGLE,RANGE)
        I=I-1
  210 CONTINUE
  800 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  FUNCTION DIFF.
C     BASED ON C.L.LAWSON AND R.J.HANSON,
C     'SOLVING LEAST SQUARES PROBLEMS', PRENTICE-HALL, 1974
C     FUNCTION DIFF(X,Y)!SP
      DOUBLE PRECISION FUNCTION DIFF(X,Y)
      DOUBLE PRECISION X, Y
      DIFF=X-Y
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE ELIMEQ.  ELIMINATES EQUALITY CONSTRAINTS USING A BASIS
C      OF THE NULL SPACE OF E (IN AEQ).  (SEE LAWSON AND HANSON,
C      CHAP. 20.)
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - H12, LH1405
C-----------------------------------------------------------------------
      SUBROUTINE ELIMEQ (AEQ,MEQ,MG,PIVOT,NEQ,NGL,A,MA,REG,MREG,
     1 NREG,NGLP1,NGLY,VK1Y1,RANGE)
      DOUBLE PRECISION A, AEQ, DUM, PIVOT, RANGE, REG, VK1Y1, ZERO
      DIMENSION AEQ(MEQ,MG), PIVOT(1), A(MA,MG), REG(MREG,MG),
     1 VK1Y1(1)
C     ZERO=0.E0!SP
      ZERO=0.D0
      DO 120 J=1,NGL
        VK1Y1(J)=ZERO
  120 CONTINUE
      IF (NEQ .EQ. 0) RETURN
      DO 150 I=1,NEQ
        II=I
        IAEQ=MIN0(I+1,NEQ)
        CALL H12 (1,II,I+1,NGL,AEQ(I,1),MEQ,PIVOT(I),AEQ(IAEQ,1),
     1  MEQ,1,NEQ-I,RANGE)
        CALL H12 (2,II,I+1,NGL,AEQ(I,1),MEQ,PIVOT(I),A(1,1),
     1  MA,1,NGLY,RANGE)
        IF (NREG .GT. 0) CALL H12 (2,II,I+1,NGL,AEQ(I,1),MEQ,
     1  PIVOT(I),REG(1,1),MREG,1,NREG,RANGE)
  150 CONTINUE
      VK1Y1(1)=AEQ(1,NGLP1)/AEQ(1,1)
      IF (NEQ .EQ. 1) GO TO 200
      DO 170 I=2,NEQ
        DUM=ZERO
        K=I-1
        DO 180 J=1,K
          DUM=DUM+AEQ(I,J)*VK1Y1(J)
  180   CONTINUE
        VK1Y1(I)=(AEQ(I,NGLP1)-DUM)/AEQ(I,I)
  170 CONTINUE
  200 CALL LH1405 (A(1,NGLP1),NGLY,NEQ,A,MA,VK1Y1)
      IF (NREG .GT. 0) CALL LH1405 (REG(1,NGLP1),NREG,NEQ,REG,MREG,
     1 VK1Y1)
      I=NEQ
      DO 230 J=1,NEQ
        CALL H12 (2,I,I+1,NGL,AEQ(I,1),MEQ,PIVOT(I),VK1Y1,1,MG,1,RANGE)
        I=I-1
  230 CONTINUE
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE ERRMES.  PRINTS ERROR MESSAGE AND STOPS IF ABORT=.TRUE..
      SUBROUTINE ERRMES (N,ABORT,IHOLER,IWRITE)
      LOGICAL ABORT
      DIMENSION IHOLER(6)
 5000 FORMAT (7H0ERROR ,6A1,I2,25H.  (CHECK USERS GUIDE.)  ,
     1 46(2H**))
      WRITE (IWRITE,5000) IHOLER,N
      IF (ABORT) STOP
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  FUNCTION FFLAT.  FFLAT=.TRUE. IF FLAT SPOTS (BINDING INEQUALITY
C      CONSTRAINTS) ARE FOUND IN SOLUTION SOLUTN.  A FLAT SPOT AT AN
C      EXTREMUM IS ONLY COUNTED IF THERE ARE TWO OR MORE SUCCESSIVE
C      BINDING CONSTRAINTS THERE.  IF NONNEG=.TRUE., THEN A FLAT SPOT
C      IS ONLY COUNTED IF ITS MAGNITUDE EXCEEDS SRMIN*(MAX. OF SOLUTN).
      LOGICAL FUNCTION FFLAT (NSGNI,NONNEG,NG,SOLUTN,SRMIN,NNQUSR,
     1 LBIND,MINEQ,LLSIGN)
      DOUBLE PRECISION ABS, AMAX1, SMIN, SOLUTN, ZERO
      LOGICAL NONNEG, LBIND
      DIMENSION SOLUTN(NG), LBIND(MINEQ), LLSIGN(NSGNI)
      AMAX1(SMIN,ZERO)=DMAX1(SMIN,ZERO)
      ABS(SMIN)=DABS(SMIN)
C     ZERO=0.E0!SP
      ZERO=0.D0
      SMIN=ZERO
      IF (.NOT.NONNEG) GO TO 120
      DO 110 J=1,NG
        SMIN=AMAX1(SMIN,SOLUTN(J))
  110 CONTINUE
      SMIN=SMIN*SRMIN
  120 FFLAT=.FALSE.
      K=NNQUSR
      NGM1=NG-1
      DO 130 J=1,NGM1
        K=K+1
        IF (LBIND(K) .AND. ABS(SOLUTN(J)) .GE. SMIN) GO TO 140
        FFLAT=.FALSE.
        GO TO 130
  140   IF (FFLAT) GO TO 800
        FFLAT=.TRUE.
        IF (NSGNI .LT. 2) GO TO 140
        DO 145 L=2,NSGNI
          LL=IABS(LLSIGN(L))
          IF (J.EQ.LL .OR. J.EQ.LL+1) GO TO 130
  145   CONTINUE
        GO TO 140
  130 CONTINUE
      FFLAT=.FALSE.
  800 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  FUNCTION FISHNI.  CALCULATES FISHER F-DISTRIBUTION FOR ARGUMENT F
C      WITH DF1 AND DF2 (NOT NECESSARILY INTEGER) DEGREES OF FREEDOM.
C      (SEE ABRAMOWITZ AND STEGUN, EQS. 26.6.2 AND 26.5.2.)
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - ERRMES, BETAIN
C  WHICH IN TURN CALL - GAMLN
C-----------------------------------------------------------------------
      FUNCTION FISHNI (F,DF1,DF2,NOUT)
      DIMENSION IHOLER(6)
      DATA IHOLER/1HF, 1HI, 1HS, 1HH, 1HN, 1HI/
      IF (AMIN1(DF1,DF2) .GT. 0.) GO TO 150
      CALL ERRMES (1,.FALSE.,IHOLER,NOUT)
      FISHNI=1.
      RETURN
  150 HDF1=.5*DF1
      HDF2=.5*DF2
      DUM=DF1*F
      FISHNI=BETAIN(DUM/(DF2+DUM),HDF1,HDF2,NOUT)
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE G1.
      SUBROUTINE G1 (A,B,COS,SIN,SIG)
C     BASED ON C.L.LAWSON AND R.J.HANSON,
C     'SOLVING LEAST SQUARES PROBLEMS', PRENTICE-HALL, 1974
C
C
C     COMPUTE ORTHOGONAL ROTATION MATRIX..
C     COMPUTE.. MATRIX   (C, S) SO THAT (C, S)(A) = (SQRT(A**2+B**2))
C                        (-S,C)         (-S,C)(B)   (   0          )
C     COMPUTE SIG = SQRT(A**2+B**2)
C        SIG IS COMPUTED LAST TO ALLOW FOR THE POSSIBILITY THAT
C        SIG MAY BE IN THE SAME LOCATION AS A OR B .
C
      DOUBLE PRECISION A, ABS, B, COS, ONE, SIG, SIGN, SIN, SQRT,
     1 XR, YR, ZERO
      ABS(A)=DABS(A)
      SQRT(A)=DSQRT(A)
      SIGN(A,B)=DSIGN(A,B)
C     ZERO=0.E0!SP
      ZERO=0.D0
C     ONE=1.E0!SP
      ONE=1.D0
      IF (ABS(A).LE.ABS(B)) GO TO 10
      XR=B/A
      YR=SQRT(ONE+XR**2)
      COS=SIGN(ONE/YR,A)
      SIN=COS*XR
      SIG=ABS(A)*YR
      RETURN
   10 IF (B) 20,30,20
   20 XR=A/B
      YR=SQRT(ONE+XR**2)
      SIN=SIGN(ONE/YR,B)
      COS=SIN*XR
      SIG=ABS(B)*YR
      RETURN
   30 SIG=ZERO
      COS=ZERO
      SIN=ONE
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE G2.
      SUBROUTINE G2    (COS,SIN,X,Y)
C     BASED ON C.L.LAWSON AND R.J.HANSON,
C     'SOLVING LEAST SQUARES PROBLEMS', PRENTICE-HALL, 1974
C          APPLY THE ROTATION COMPUTED BY G1 TO (X,Y).
      DOUBLE PRECISION COS, SIN, X, XR, Y
      XR=COS*X+SIN*Y
      Y=-SIN*X+COS*Y
      X=XR
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  FUNCTION GAMLN.  COMPUTES LN OF THE GAMMA FUNCTION FOR POSITIVE
C      XARG USING A VERSION OF CACM ALGORITHM NO. 291.
      FUNCTION GAMLN (XARG)
      X=XARG
      P=1.
      GAMLN=0.
  110 IF (X .GE. 7.) GO TO 150
      P=P*X
      X=X+1.
      GO TO 110
  150 IF (XARG .LT. 7.) GAMLN=-ALOG(P)
      Z=1./X**2
      GAMLN=GAMLN+(X-.5)*ALOG(X)-X+.9189385-(((Z/1680.-
     1 7.936508E-4)*Z+2.777778E-3)*Z-8.333333E-2)/X
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE GETPRU.  DOES CORRELATION AND RUNS TEST ON RESIDUALS
C      (COMPUTED USING SOLUTION SOL).  GETPRU IS THE APPROX.
C      PROBABILITY THAT A RANDOMLY CHOSEN ORDER OF SIGNS WOULD HAVE
C      NO MORE RUNS THAN THE RESIDUALS.  APPROX. IS ONLY GOOD IF
C      THERE ARE AT LEAST OF THE ORDER OF 10 POSITIVE AND
C      10 NEGATIVE RESIDUALS.  THEREFORE IF THERE ARE NOT AT LEAST 10 OF
C      EACH SIGN, GETPRU IS SET TO -1.
C  PUNCOR(J), J=1,...,5, IS THE APPROX. PROBABILITY THAT A RANDOM
C      SAMPLE FROM A NORMAL POPULATION WOULD HAVE A SMALLER
C      AUTOCOVARIANCE FOR LAG J THAN THE RESIDUALS.  IF NY.LE.5, THEN
C      ALL PUNCOR ARE SET TO -1.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - GETYLY, PGAUSS, FISHNI
C  WHICH IN TURN CALL - GETROW, USERK, USERLF, ERRMES, BETAIN, GAMLN
C-----------------------------------------------------------------------
      SUBROUTINE GETPRU (SOL,
     1 CQUAD,G,IUNIT,IWT,MWORK,NG,NGL,NLINF,NOUT,NY,PRUNS,PUNCOR,SQRTW,
     2 SSCALE,T,WORK,Y,YLYFIT)
      DOUBLE PRECISION SOL, SSCALE, WORK
      DIMENSION WORK(MWORK), SQRTW(NY), CQUAD(NG), G(NG), T(NY),
     1 Y(NY), YLYFIT(NY), SOL(NGL), SSCALE(NGL)
      DIMENSION PUNCOR(5)
      CALL GETYLY (SOL,
     1 CQUAD,G,IUNIT,IWT,MWORK,NG,NGL,NLINF,NY,SQRTW,SSCALE,T,WORK,Y,
     2 YLYFIT)
C-----------------------------------------------------------------------
C  RUNS TEST.
C-----------------------------------------------------------------------
      YLYOLD=-YLYFIT(1)
      NRUN=0
      DDUM=0.
      DO 110 IROW=1,NY
        DUM=YLYFIT(IROW)
        DDUM=DDUM+SIGN(1.,DUM)
        IF (DUM*YLYOLD .LT. 0.) NRUN=NRUN+1
        YLYOLD=DUM
  110 CONTINUE
      RN1=.5*(FLOAT(NY)+DDUM)
      RN2=RN1-DDUM
      DUM=2.*RN1*RN2
      RMU=DUM/(RN1+RN2)+1.
      SIG=SQRT(DUM*(DUM-RN1-RN2)/(RN1+RN2-1.))/(RN1+RN2)
      PRUNS=-1.
      IF (AMIN1(RN1,RN2) .GT. 9.5) PRUNS=PGAUSS((FLOAT(NRUN)-RMU+.5)/
     1 SIG)
C-----------------------------------------------------------------------
C  TEST AUTOCOVARIANCES.
C-----------------------------------------------------------------------
      DO 120 J=1,5
        PUNCOR(J)=-1.
  120 CONTINUE
      IF (NY .LE. 7) RETURN
      RSUMST=0.
      DO 130 K=1,NY
  130 RSUMST=RSUMST+YLYFIT(K)
      RSUMEN=RSUMST
      DO 150 L=1,5
      NEND=NY-L
      RSUMST=RSUMST-YLYFIT(NEND+1)
      RSUMEN=RSUMEN-YLYFIT(L)
      STBAR=RSUMST/FLOAT(NEND)
      ENBAR=RSUMEN/FLOAT(NEND)
      SS=0.
      SE=0.
      EE=0.
      J=L
      DO 152 K=1,NEND
      S=YLYFIT(K)-STBAR
      J=J+1
      E=YLYFIT(J)-ENBAR
      SS=SS+S*S
      SE=SE+S*E
      EE=EE+E*E
  152 CONTINUE
      RSQ=SE*SE/(SS*EE)
      PUNCOR(L)=0.
      IF (RSQ .LT. 1.) PUNCOR(L)=1.-FISHNI(FLOAT(NEND-2)*RSQ/(1.-RSQ),
     1 1.,FLOAT(NEND-2),NOUT)
  150 CONTINUE
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE GETROW.  LOADS ROW IROW OF SCALED AUGMENTED COEFFICIENT
C      MATRIX INTO ARRAY A IN STORAGE INCREMENTS OF INC.
C  IF IUNIT .LT. 0, THEN THE MATRIX ELEMENTS ARE RECALCULATED
C      EACH TIME.
C  IF IUNIT .GE. 0, THEN THE MATRIX ELEMENTS ARE CALCULATED
C      AND WRITTEN ON UNIT IUNIT (IF INIT=.TRUE.), OR READ FROM UNIT
C      IUNIT (IF INIT=.FALSE.).
C  THEREFORE, IF IUNIT .GE. 0, THEN GETROW MUST BE CALLED IN A
C      SEQUENCE SUCH THAT IROW GOES FROM 1 TO NY.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - USERK, USERLF
C  WHICH IN TURN CALL - ERRMES, USERTR
C-----------------------------------------------------------------------
      SUBROUTINE GETROW (IROW,A,INIT,INC,IUNIT,
     1  SQRTW,NY,NGL,NG,CQUAD,G,T,NLINF,Y,SSCALE)
      DOUBLE PRECISION A, SSCALE
      LOGICAL INIT
      DIMENSION SQRTW(NY), A(1), CQUAD(NG), G(NG), T(NY), Y(NY),
     1 SSCALE(NGL)
      SWT=SQRTW(IROW)
      JJ=1+INC*NGL
      IF (IUNIT.LT.0 .OR. INIT) GO TO 200
C-----------------------------------------------------------------------
C  READ IN ELEMENTS FROM UNIT IUNIT.
C-----------------------------------------------------------------------
      READ (IUNIT) (A(J),J=1,JJ,INC)
      GO TO 300
C-----------------------------------------------------------------------
C  CALCULATE MATRIX ELEMENTS.
C-----------------------------------------------------------------------
  200 K=1
      DO 210 J=1,NG
        JJJ=J
        A(K)=SSCALE(J)*CQUAD(J)*SWT*USERK(IROW,T,JJJ,G)
        K=K+INC
  210 CONTINUE
      IF (NLINF .LE. 0) GO TO 230
      IS=NG
      DO 220 J=1,NLINF
        JJJ=J
        IS=IS+1
        A(K)=SSCALE(IS)*SWT*USERLF(IROW,JJJ,T,NY)
        K=K+INC
  220 CONTINUE
  230 A(K)=Y(IROW)*SWT
      IF (IUNIT .LT. 0) GO TO 800
      WRITE (IUNIT) (A(J),J=1,JJ,INC)
  300 IF (IROW .EQ. NY) REWIND IUNIT
  800 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE GETYLY.  PUTS RESIDUALS (USING SOLUTION IN SOL)
C      IN YLYFIT(J), J=1,NY.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - GETROW
C  WHICH IN TURN CALL - USERK, USERLF, ERRMES, USERTR
C-----------------------------------------------------------------------
      SUBROUTINE GETYLY (SOL,
     1 CQUAD,G,IUNIT,IWT,MWORK,NG,NGL,NLINF,NY,SQRTW,SSCALE,T,WORK,Y,
     2 YLYFIT)
      DOUBLE PRECISION DUM, SOL, WORK, SSCALE
      DIMENSION WORK(MWORK), SQRTW(NY), CQUAD(NG), G(NG), T(NY),
     1 Y(NY), YLYFIT(NY), SOL(NGL), SSCALE(NGL)
      DO 110 IROW=1,NY
        IIROW=IROW
        CALL GETROW (IIROW,WORK,.FALSE.,1,IUNIT,
     1  SQRTW,NY,NGL,NG,CQUAD,G,T,NLINF,Y,SSCALE)
        DUM=WORK(NGL+1)
        DO 120 ICOL=1,NGL
          DUM=DUM-WORK(ICOL)*SOL(ICOL)
  120   CONTINUE
        YLYFIT(IROW)=DUM
  110 CONTINUE
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C     SUBROUTINE H12 (MODE,LPIVOT,L1,M,U,IUE,UP,C,ICE,ICV,NCV,RANGE)
C     BASED ON C.L.LAWSON AND R.J.HANSON,
C     'SOLVING LEAST SQUARES PROBLEMS', PRENTICE-HALL, 1974
C
C     CONSTRUCTION AND/OR APPLICATION OF A SINGLE
C     HOUSEHOLDER TRANSFORMATION..     Q = I + U*(U**T)/B
C
C     MODE    = 1 OR 2   TO SELECT ALGORITHM  H1  OR  H2 .
C     LPIVOT IS THE INDEX OF THE PIVOT ELEMENT.
C     L1,M   IF L1 .LE. M   THE TRANSFORMATION WILL BE CONSTRUCTED TO
C            ZERO ELEMENTS INDEXED FROM L1 THROUGH M.   IF L1 GT. M
C            THE SUBROUTINE DOES AN IDENTITY TRANSFORMATION.
C     U(),IUE,UP    ON ENTRY TO H1 U() CONTAINS THE PIVOT VECTOR.
C                   IUE IS THE STORAGE INCREMENT BETWEEN ELEMENTS.
C                                       ON EXIT FROM H1 U() AND UP
C                   CONTAIN QUANTITIES DEFINING THE VECTOR U OF THE
C                   HOUSEHOLDER TRANSFORMATION.   ON ENTRY TO H2 U()
C                   AND UP SHOULD CONTAIN QUANTITIES PREVIOUSLY COMPUTED
C                   BY H1.  THESE WILL NOT BE MODIFIED BY H2.
C     C()    ON ENTRY TO H1 OR H2 C() CONTAINS A MATRIX WHICH WILL BE
C            REGARDED AS A SET OF VECTORS TO WHICH THE HOUSEHOLDER
C            TRANSFORMATION IS TO BE APPLIED.  ON EXIT C() CONTAINS THE
C            SET OF TRANSFORMED VECTORS.
C     ICE    STORAGE INCREMENT BETWEEN ELEMENTS OF VECTORS IN C().
C     ICV    STORAGE INCREMENT BETWEEN VECTORS IN C().
C     NCV    NUMBER OF VECTORS IN C() TO BE TRANSFORMED. IF NCV .LE. 0
C            NO OPERATIONS WILL BE DONE ON C().
C  RANGE IS 2 OR 3 ORDERS OF MAGNITUDE SMALLER THAN BIG, WHERE BIG IS
C      THE LARGEST NUMBER THAT DOES NOT OVERFLOW AND 1/BIG DOES NOT
C      UNDERFLOW.  FOR THE DOUBLE PRECISION VERSION, BIG AND RANGE
C      ARE IN DOUBLE PRECISION.  FOR THE SINGLE PRECISION VERSION,
C      THEY ARE IN SINGLE PRECISION (AND THEREFORE RANGE=SRANGE).
C
      SUBROUTINE H12 (MODE,LPIVOT,L1,M,U,IUE,UP,C,ICE,ICV,NCV,RANGE)
      DIMENSION U(IUE,1), C(1)
      DOUBLE PRECISION SM,B
      DOUBLE PRECISION ABS, AMAX1, C, CL, CLINV, DOUBLE, ONE, RANGE,
     1 RANGIN, SIGN, SM1, SQRT, U, UP
      ABS(SM)=DABS(SM)
      AMAX1(SM,ONE)=DMAX1(SM,ONE)
C     DOUBLE(ONE)=DBLE(ONE)!SP
      DOUBLE(SM)=SM
      SQRT(SM)=DSQRT(SM)
      SIGN(SM,ONE)=DSIGN(SM,ONE)
C     ONE=1.E0!SP
      ONE=1.D0
C
      IF (0.GE.LPIVOT.OR.LPIVOT.GE.L1.OR.L1.GT.M) RETURN
      RANGIN=ONE/RANGE
      CL=ABS(U(1,LPIVOT))
      IF (MODE.EQ.2) GO TO 60
C                            ****** CONSTRUCT THE TRANSFORMATION. ******
          DO 10 J=L1,M
   10     CL=AMAX1(ABS(U(1,J)),CL)
      IF (CL .LE. RANGIN) GO TO 130
      CLINV=ONE/CL
      SM=(DOUBLE(U(1,LPIVOT))*CLINV)**2
          DO 30 J=L1,M
   30     SM=SM+(DOUBLE(U(1,J))*CLINV)**2
C                          CONVERT DOUBLE PREC. SM TO SNGL. PREC. SM1
      SM1=SM
      CL=-SIGN(CL*SQRT(SM1),U(1,LPIVOT))
      UP=U(1,LPIVOT)-CL
      U(1,LPIVOT)=CL
      GO TO 70
C            ****** APPLY THE TRANSFORMATION  I+U*(U**T)/B  TO C. ******
C
   60 IF (CL .LE. RANGIN) GO TO 130
   70 IF (NCV.LE.0) RETURN
      B=DOUBLE(UP)*U(1,LPIVOT)
C                       B  MUST BE NONPOSITIVE HERE.  IF B = 0., RETURN.
C
      IF (B .GE. -RANGIN) GO TO 130
      B=ONE/B
      I2=1-ICV+ICE*(LPIVOT-1)
      INCR=ICE*(L1-LPIVOT)
          DO 120 J=1,NCV
          I2=I2+ICV
          I3=I2+INCR
          I4=I3
          SM=C(I2)*DOUBLE(UP)
              DO 90 I=L1,M
              SM=SM+C(I3)*DOUBLE(U(1,I))
   90         I3=I3+ICE
          IF (SM) 100,120,100
  100     SM=SM*B
          C(I2)=C(I2)+SM*DOUBLE(UP)
              DO 110 I=L1,M
              C(I4)=C(I4)+SM*DOUBLE(U(1,I))
  110         I4=I4+ICE
  120     CONTINUE
  130 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE INIT.  INITIALIZES VARIABLES AT THE START OF A RUN.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - DIFF, ERRMES
C-----------------------------------------------------------------------
      SUBROUTINE INIT
      DOUBLE PRECISION PRECIS, RANGE
      DOUBLE PRECISION ONE, ZERO, PREMIN, DIFF,
     1 SMALL, SIZE, PTRY, DELTRY, AMAX1
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      LOGICAL DONE1
      DIMENSION IHOLER(6)
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE,YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
      DATA IHOLER/1HI, 1HN, 1HI, 1HT, 2*1H /
      AMAX1(PTRY,PRECIS)=DMAX1(PTRY,PRECIS)
C     ONE=1.E0!SP
      ONE=1.D0
C     ZERO=0.E0!SP
      ZERO=0.D0
C     PREMIN=1.E-4!SP
      PREMIN=1.D-8
      FACT=RANGE**(-.025)
      SMALL=ONE/RANGE
      DONE1=.FALSE.
      SIZE=RANGE
      DO 110 J=1,80
        PTRY=PREMIN
        DO 120 K=1,150
          PTRY=.5*PTRY
          DELTRY=PTRY*SIZE
          IF (DELTRY .LT. SMALL) GO TO 140
          IF (DIFF(SIZE+DELTRY,SIZE) .LE. ZERO) GO TO 130
  120   CONTINUE
  130   IF (DONE1) PRECIS=AMAX1(PTRY,PRECIS)
        IF (.NOT.DONE1) PRECIS=PTRY
        DONE1=.TRUE.
        SIZE=FACT*SIZE
  110 CONTINUE
  140 PRECIS=20.*PRECIS
      IF (PRECIS .GT. PREMIN) CALL ERRMES (1,.TRUE.,IHOLER,NOUT)
      MIOERR=MAX0(2,MIOERR)
      EXMAX=ALOG(SRANGE)
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE INPUT.  READS INPUT DATA, WRITES IT OUT, AND CHECKS
C      FOR INPUT ERRORS.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - STORIN, ERRMES, READYT, WRITIN
C  WHICH IN TURN CALL - USERIN, WRITYT
C-----------------------------------------------------------------------
      SUBROUTINE INPUT (EXACT,G,MA,MEQ,MG,MINEQ,MREG,MWORK,MY,SQRTW,T,Y)
      DOUBLE PRECISION PRECIS, RANGE
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      LOGICAL LERR
      DIMENSION SQRTW(MY), T(MY), Y(MY), EXACT(MY), G(MG)
      DIMENSION LIN(6), LA(6,50), LA1(6,13), LA2(6,13), LA3(6,13),
     1 LA4(6,11), IHOLER(6)
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
C-----------------------------------------------------------------------
C  LA IS BEING BROKEN UP JUST TO KEEP THE NO. OF CONTINUATION
C      CARDS IN THE DATA STATEMENTS SMALL.
C-----------------------------------------------------------------------
      EQUIVALENCE (LA(1,1),LA1(1,1)), (LA(1,14),LA2(1,1)),
     1 (LA(1,27),LA3(1,1)), (LA(1,40),LA4(1,1))
      DATA MLA/50/, IHOLER/1HI, 1HN, 1HP, 1HU, 1HT, 1H /
      DATA LA1/
     1 1HD, 1HF, 1HM, 1HI, 1HN, 1H ,
     2 1HS, 1HR, 1HM, 1HI, 1HN, 1H ,   1HA, 1HL, 1HP, 1HS, 1HT, 1H ,
     3 1HG, 1HM, 1HN, 1HM, 1HX, 1H ,   1HP, 1HL, 1HE, 1HV, 1HE, 1HL,
     4 1HR, 1HS, 1HV, 1HM, 1HN, 1HX,   1HR, 1HU, 1HS, 1HE, 1HR, 1H ,
     5 1HI, 1HG, 1HR, 1HI, 1HD, 1H ,   1HI, 1HQ, 1HU, 1HA, 1HD, 1H ,
     6 1HI, 1HU, 1HN, 1HI, 1HT, 1H ,   1HI, 1HW, 1HT, 3*1H ,
     7 1HL, 1HI, 1HN, 1HE, 1HP, 1HG,   1HM, 1HI, 1HO, 1HE, 1HR, 1HR/
      DATA LA2/
     1 1HM, 1HP, 1HK, 1HM, 1HO, 1HM,   1HM, 1HQ, 1HP, 1HI, 1HT, 1HR,
     2 1HN, 1HE, 1HQ, 3*1H ,           1HN, 1HE, 1HR, 1HF, 1HI, 1HT,
     3 1HN, 1HG, 4*1H ,                1HN, 1HI, 1HN, 1HT, 1HT, 1H ,
     4 1HN, 1HL, 1HI, 1HN, 1HF, 1H ,   1HN, 1HO, 1HR, 1HD, 1HE, 1HR,
     5 1HI, 1HC, 1HR, 1HI, 1HT, 1H ,
     6 1HI, 1HF, 1HO, 1HR, 1HM, 1HT,   1HI, 1HF, 1HO, 1HR, 1HM, 1HW,
     7 1HI, 1HF, 1HO, 1HR, 1HM, 1HY,   1HI, 1HP, 1HL, 1HF, 1HI, 1HT/
      DATA LA3/
     1 1HI, 1HP, 1HL, 1HR, 1HE, 1HS,   1HI, 1HP, 1HR, 1HI, 1HN, 1HT,
     2 1HI, 1HU, 1HS, 1HE, 1HR, 1H ,   1HI, 1HU, 1HS, 1HR, 1HO, 1HU,
     3 1HL, 1HS, 1HI, 1HG, 1HN, 1H ,   1HM, 1HO, 1HM, 1HN, 1HM, 1HX,
     4 1HN, 1HE, 1HN, 1HD, 1HZ, 1H ,   1HN, 1HF, 1HL, 1HA, 1HT, 1H ,
     5 1HN, 1HN, 1HS, 1HG, 1HN, 1H ,   1HN, 1HQ, 1HP, 1HR, 1HO, 1HG,
     6 1HN, 1HS, 1HG, 1HN, 2*1H ,      1HD, 1HO, 1HC, 1HH, 1HO, 1HS,
     7 1HD, 1HO, 1HM, 1HO, 1HM, 1H /
      DATA LA4/
     1 1HD, 1HO, 1HU, 1HS, 1HI, 1HN,   1HD, 1HO, 1HU, 1HS, 1HN, 1HQ,
     2 1HL, 1HA, 1HS, 1HT, 2*1H ,      1HN, 1HE, 1HW, 1HP, 1HG, 1H1,
     3 1HN, 1HO, 1HN, 1HN, 1HE, 1HG,   1HO, 1HN, 1HL, 1HY, 1H1, 1H ,
     4 1HP, 1HR, 1HW, 1HT, 2*1H ,      1HP, 1HR, 1HY, 3*1H ,
     5 1HS, 1HI, 1HM, 1HU, 1HL, 1HA,   1HL, 1HU, 1HS, 1HE, 1HR, 1H ,
     6 1HE, 1HN, 1HD, 3*1H /
 5100 FORMAT (80A1)
      READ (NIN,5100) ITITLE
 5999 FORMAT (1H1)
      IF (NEWPG1) WRITE (33,5999)
 5101 FORMAT (34H CONTIN - VERSION 2DP (AUG 1982) (,6A1,6H PACK),6X,80A1
     1 //59H REFERENCES - S.W. PROVENCHER (1982) COMPUT. PHYS. COMMUN.,,
     2 33H VOL. 27, PAGES 213-227, 229-242./30X,
     3 53H(1982) EMBL TECHNICAL REPORT DA05 (EUROPEAN MOLECULAR,
     4 49H BIOLOGY LABORATORY, HEIDELBERG, F.R. OF GERMANY)
     5 ///20X,42HINPUT DATA FOR CHANGES TO COMMON VARIABLES)
      WRITE (33,5101) IAPACK, ITITLE
      NIOERR=0
 5200 FORMAT (1X,6A1,I5,E15.6)
  200 READ (NIN,5200) LIN,IIN,RIN
 5210 FORMAT (/1X,6A1,I5,1PE15.5)
      WRITE (33,5210) LIN,IIN,RIN
      DO 210 J=1,MLA
        DO 220 K=1,6
          IF (LIN(K) .NE. LA(K,J)) GO TO 210
  220   CONTINUE
        IF (J .EQ. MLA) GO TO 3008
        JJ=J
        CALL STORIN (JJ,NIOERR,LIN,IIN,RIN)
        GO TO 200
  210 CONTINUE
C***********************************************
 3008 CONTINUE
 2000 READ (50,5200) LIN,IIN,RIN
      WRITE (33,5210) LIN,IIN,RIN
      DO 2100 J=1,MLA
        DO 215 K=1,6
          IF (LIN(K) .NE. LA(K,J)) GO TO 2100
  215   CONTINUE
        IF (J .EQ. MLA) GO TO 3009
        JJ=J
        CALL STORIN (JJ,NIOERR,LIN,IIN,RIN)
        GO TO 2000
 2100 CONTINUE
C&&&&&&&&&&
 3009 CONTINUE
 2001 READ (51,5200) LIN,IIN,RIN
      WRITE (33,5210) LIN,IIN,RIN
      DO 2101 J=1,MLA
        DO 225 K=1,6
          IF (LIN(K) .NE. LA(K,J)) GO TO 2101
  225   CONTINUE
        IF (J .EQ. MLA) GO TO 300
        JJ=J
        CALL STORIN (JJ,NIOERR,LIN,IIN,RIN)
        GO TO 2001
 2101 CONTINUE
C***********************************************
      CALL ERRMES (1,.FALSE.,IHOLER,NOUT)
 5001 FORMAT (1H )
      WRITE (33,5001)
      NIOERR=NIOERR+1
      IF (NIOERR .GE. MIOERR) STOP
      GO TO 200
  300 CALL READYT (MY,NIOERR,SQRTW,T,Y)
      CALL WRITIN (EXACT,G,LA,MG,MY,SQRTW,T,Y)
      NEWPG1=.TRUE.
C-----------------------------------------------------------------------
C  CHECK COMMON VARIABLES FOR VIOLATIONS.
C-----------------------------------------------------------------------
      LERR=.FALSE.
      DO 410 K=1,2
        DO 420 J=1,2
          IF (K.EQ.2 .OR. (IWT.NE.1 .AND. IWT.NE.4)) LERR=LERR .OR.
     1    PLEVEL(J,K).LT.0. .OR. PLEVEL(J,K).GT.1. .OR. ICRIT(K).LT.1
     2     .OR. ICRIT(K).GT.2
  420   CONTINUE
        IF (NQPROG(1) .GT. 0) LERR=LERR .OR. RSVMNX(K,1).LE.0.
  410 CONTINUE
C      PRINT*,'IGRID, IQUAD, IWT, NG, NLINF, NEQ, MEQ, MG, MA=',
C     &        IGRID, IQUAD, IWT, NG, NLINF, NEQ, MEQ, MG, MA
C      PRINT*,'MREG, NORDER, NY, MY, MINEQ, MWORK =',
C     &        MREG, NORDER, NY, MY, MINEQ, MWORK
      LERR=LERR .OR. MIN0(IGRID,IQUAD,IWT,NG-1,NG+NLINF-NEQ).LT.1 .OR.
     1 MIN0(NLINF,NEQ).LT.0 .OR.
     2 MAX0(IGRID-3,IQUAD-3,IWT-5,NEQ-MEQ,NG+NLINF+2-MIN0(MG,MA),
     3 NG+NLINF+1-MREG,NORDER-5,
     4 MAX0(MG,NY)-MY,MAX0((MINEQ+2)*(MG+1)-4,MG*(MG-2),4*MG)-MWORK)
     5 .GT. 0
      IF (.NOT.LERR) GO TO 500
      CALL ERRMES (2,.FALSE.,IHOLER,NOUT)
 5420 FORMAT (5H MY =,I5,5X,4HMA =,I3,5X,4HMG =,I3,5X,6HMREG =,I3,5X,
     1 7HMINEQ =,I3,5X,5HMEQ =,I3,5X,7HMWORK =,I5)
      WRITE (33,5420) MY,MA,MG,MREG,MINEQ,MEQ,MWORK
      STOP
  500 IF (NIOERR .NE. 0) STOP
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
      SUBROUTINE LDP (G,MDG,M,N,H,X,XNORM,W,INDEX,MODE,RANGE)
C     BASED ON C.L.LAWSON AND R.J.HANSON,
C     'SOLVING LEAST SQUARES PROBLEMS', PRENTICE-HALL, 1974
C
C            **********  LEAST DISTANCE PROGRAMMING  **********
C
C  RANGE IS 2 OR 3 ORDERS OF MAGNITUDE SMALLER THAN BIG, WHERE BIG IS
C      THE LARGEST NUMBER THAT DOES NOT OVERFLOW AND 1/BIG DOES NOT
C      UNDERFLOW.  FOR THE DOUBLE PRECISION VERSION, BIG AND RANGE
C      ARE IN DOUBLE PRECISION.  FOR THE SINGLE PRECISION VERSION,
C      THEY ARE IN SINGLE PRECISION (AND THEREFORE RANGE=SRANGE).
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - DIFF, NNLS
C  WHICH IN TURN CALL - H12, G1, G2
C-----------------------------------------------------------------------
      DOUBLE PRECISION DIFF, FAC, G, H, ONE, RANGE, RNORM,
     1 SQRT, W, X, XNORM, ZERO
      INTEGER INDEX(M)
      DIMENSION G(MDG,N), H(M), X(1), W(1)
      SQRT(FAC)=DSQRT(FAC)
C     ZERO=0.E0!SP
      ZERO=0.D0
C     ONE=1.E0!SP
      ONE=1.D0
      IF (N.LE.0) GO TO 120
          DO 10 J=1,N
   10     X(J)=ZERO
      XNORM=ZERO
      IF (M.LE.0) GO TO 110
C
C     THE DECLARED DIMENSION OF W() MUST BE AT LEAST (N+1)*(M+2)+2*M.
C
C      FIRST (N+1)*M LOCS OF W()   =  MATRIX E FOR PROBLEM NNLS.
C       NEXT     N+1 LOCS OF W()   =  VECTOR F FOR PROBLEM NNLS.
C       NEXT     N+1 LOCS OF W()   =  VECTOR Z FOR PROBLEM NNLS.
C       NEXT       M LOCS OF W()   =  VECTOR Y FOR PROBLEM NNLS.
C       NEXT       M LOCS OF W()   =  VECTOR WDUAL FOR PROBLEM NNLS.
C     COPY G**T INTO FIRST N ROWS AND M COLUMNS OF E.
C     COPY H**T INTO ROW N+1 OF E.
C
      IW=0
          DO 30 J=1,M
              DO 20 I=1,N
              IW=IW+1
   20         W(IW)=G(J,I)
          IW=IW+1
   30     W(IW)=H(J)
      IF=IW+1
C                                STORE N ZEROS FOLLOWED BY A ONE INTO F.
          DO 40 I=1,N
          IW=IW+1
   40     W(IW)=ZERO
      W(IW+1)=ONE
C
      NP1=N+1
      IZ=IW+2
      IY=IZ+NP1
      IWDUAL=IY+M
C
      CALL NNLS (W,NP1,NP1,M,W(IF),W(IY),RNORM,W(IWDUAL),W(IZ),INDEX,
     *           MODE,RANGE)
C                      USE THE FOLLOWING RETURN IF UNSUCCESSFUL IN NNLS.
      IF (MODE.NE.1) RETURN
      IF (RNORM) 130,130,50
   50 FAC=ONE
      IW=IY-1
          DO 60 I=1,M
          IW=IW+1
C                               HERE WE ARE USING THE SOLUTION VECTOR Y.
   60     FAC=FAC-H(I)*W(IW)
C
      IF (DIFF(ONE+FAC,ONE)) 130,130,70
   70 FAC=ONE/FAC
          DO 90 J=1,N
          IW=IY-1
              DO 80 I=1,M
              IW=IW+1
C                               HERE WE ARE USING THE SOLUTION VECTOR Y.
   80         X(J)=X(J)+G(I,J)*W(IW)
   90     X(J)=X(J)*FAC
          DO 100 J=1,N
  100     XNORM=XNORM+X(J)**2
      XNORM=SQRT(XNORM)
C                             SUCCESSFUL RETURN.
  110 MODE=1
      RETURN
C                             ERROR RETURN.       N .LE. 0.
  120 MODE=2
      RETURN
C                             RETURNING WITH CONSTRAINTS NOT COMPATIBLE.
  130 MODE=4
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE LDPETC.  EVALUATES CONSTRAINED REGULARIZED SOLUTION
C      USING LEAST-DISTANCE PROGRAMMING.
C  DOES STATISTICAL TESTS ON SOLUTION AND STORES IT IN SOLBES IF IT
C      IS THE BEST SO FAR AND IF SSEARC=.TRUE..
C  PPLTPR=.TRUE. FOR COMPUTING COVARIANCE MATRIX FOR
C      PLOT OF SOLUTION ON PRINTER OR CALL TO USEROU.
C  PRINTS OUT MOMENTS IF DOMOM=PPLTPR=.TRUE..
C  NEWPAG=.TRUE. FOR STARTING A NEW PAGE.
C  HEADNG=.TRUE. FOR PRINTING A HEADING FOR ONE-LINE SUMMARIES.
C  PRLDP=.TRUE. FOR PRINTING OUT ONE-LINE SUMMARY OF ANALYSIS.
C  IICRIT=ICRIT(ISTAGE) IN CALLING PROGRAM.
C  NNNNEQ=CURRENT NO. OF INEQUALITY CONSTRAINTS.
C  ON RETURN, IERROR = 1 FOR NORMAL RETURN
C                      3 FOR MAX. NO. OF ITERATIONS IN NNLS IN LDP
C                      5 FOR ERROR RETURN FROM SVDRS2 IN CVNEQ.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - LDP, ERRMES, CVNEQ, GETYLY, FISHNI, PLPRIN,
C      USEROU, MOMENT
C  WHICH IN TURN CALL - NNLS, DIFF, H12, G1, G2, GETROW, USERK, USERLF,
C      ELIMEQ, SVDRS2, LH1405, QRBD, BETAIN, GAMLN, MOMOUT, USERTR
C-----------------------------------------------------------------------
      SUBROUTINE LDPETC (ILEVEL,FINDVZ,NNNNEQ,SSEARC,IICRIT,DDOMOM,
     1 PPLTPR,PRLDP,ALPHA,HEADNG,NEWPAG,ALPBES,VAR,
     2  A,AA,AINEQ,BTEST,CQUAD,DEGFRE,DEGFRZ,EXACT,G,IERROR,
     3  ISTAGE,IWORK,LBIND,MA,MG,MINEQ,MREG,MWORK,MY,
     4  NGLE,NGLY,PREJ,REG,RHSNEQ,RS2MNX,S,SOLBES,
     5  SOLUTN,SQRTW,SSCALE,T,VALPCV,VALPHA,VARREG,VARZ,WORK,Y,YLYFIT)
      DOUBLE PRECISION PRECIS, RANGE
      DOUBLE PRECISION A, AA, AAMAX, AASCMX, ABS, AINEQ, ALPBES,
     1 ALPHA, AMAX1, DUB, REG, RHSNEQ, S, SOLBES, SOLUTN, SQRT,
     2 SSCALE, VALPCV, VALPHA, WORK, ZERO
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      LOGICAL FINDVZ, SSEARC, PPLTPR, LBIND, PRLDP, DDOMOM,
     1 NEWPAG, HEADNG, DOERR
      DIMENSION SOLUTN(MG), VALPHA(MG), S(MG,3), A(MA,MG),
     1 AINEQ(MINEQ,MG), RHSNEQ(MINEQ), WORK(MWORK), IWORK(MA),
     2 REG(MREG,MG), VALPCV(MG), G(MG), EXACT(MG),
     3 CQUAD(MG), SOLBES(MG), PREJ(2), SSCALE(MG),
     4 LBIND(MINEQ), AA(MG,MG), SQRTW(MY), T(MY), Y(MY), YLYFIT(MY)
      DIMENSION IHOLER(6), ISTAR(2), RS2MNX(2)
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
      DATA IHOLER/1HL, 1HD, 1HP, 1HE, 1HT, 1HC/, ISTAR/1H , 1H*/
      ABS(DUB)=DABS(DUB)
      SQRT(DUB)=DSQRT(DUB)
      AMAX1(DUB,AAMAX)=DMAX1(DUB,AAMAX)
C     ZERO=0.E0!SP
      ZERO=0.D0
      DEGFRE=0.
      LSTAR=1
      VAR=SRANGE
      VARREG=SRANGE
      DO 105 J=1,NGL
        SOLUTN(J)=VALPHA(J)
        S(J,3)=ZERO
  105 CONTINUE
      IF (NNNNEQ .EQ. 0) GO TO 240
C-----------------------------------------------------------------------
C  PUT SOLUTION OF LEAST-DISTANCE PROGRAMMING PROBLEM IN S(J,3),
C      J=1,NGLE.
C-----------------------------------------------------------------------
      CALL LDP (A,MA,NNNNEQ,NGLE,RHSNEQ,S(1,3),DUB,WORK,IWORK,IERROR,
     1 RANGE)
      GO TO (240,210,220,230),IERROR
  210 CALL ERRMES (1,.TRUE.,IHOLER,NOUT)
  220 DDUM=ALPHA/S(1,1)
 5220 FORMAT (41H0MAX. ITERATIONS IN NNLS FOR ALPHA/S(1) =,1PE9.2)
      WRITE (33,5220) DDUM
      RETURN
  230 CALL ERRMES (2,.FALSE.,IHOLER,NOUT)
      RETURN
  240 VARREG=0.
      DO 250 ICOL=1,NGLE
C-----------------------------------------------------------------------
C  EVALUATE ELEMENT ICOL OF S(TILDE)**(-1)*XI IN EQ. (5.29).
C-----------------------------------------------------------------------
        DUB=S(ICOL,2)*S(ICOL,3)
C-----------------------------------------------------------------------
C  COMPUTE PENALTY CONTRIBUTION OF REGULARIZOR TO OBJECTIVE FUNCTION.
C-----------------------------------------------------------------------
        VARREG=VARREG+(DUB+S(ICOL,2)**2*S(ICOL,1)*(A(ICOL,NGLP1)-
     1  S(ICOL,1)*REG(ICOL,NGLP1)))**2
        DO 255 IROW=1,NGL
          SOLUTN(IROW)=SOLUTN(IROW)+REG(IROW,ICOL)*DUB
  255   CONTINUE
  250 CONTINUE
      CALL CVNEQ (ALPHA,IERROR,NNNNEQ,SOLUTN,
     1 A,AA,AINEQ,DEGFRE,LBIND,MA,MG,MINEQ,MREG,MWORK,NGL,NGLE,
     2 NGLP1,NGLY,NOUT,PPLTPR,RANGE,REG,S,VALPCV,WORK)
C-----------------------------------------------------------------------
C  COMPUTE VAR (VARIANCE OF FIT).
C-----------------------------------------------------------------------
      CALL GETYLY (SOLUTN,
     1 CQUAD,G,IUNIT,IWT,MWORK,NG,NGL,NLINF,NY,SQRTW,SSCALE,T,WORK,Y,
     2 YLYFIT)
      VAR=0.
      DO 310 J=1,NY
        VAR=VAR+YLYFIT(J)**2
  310 CONTINUE
      VARREG=VARREG*ALPHA**2+VAR
      IF (VARZ.LT.VAR .OR. .NOT.FINDVZ .OR. IERROR.NE.1) GO TO 320
      LSTAR=2
      DEGFRZ=DEGFRE
      VARZ=VAR
  320 PREJ(1)=-1.
      PREJ(2)=-1.
      IF (VARZ.GE.SRANGE .OR. IERROR.NE.1) GO TO 325
      DDUM=AMAX1(ZERO,VAR/VARZ-1.-ZERO)
      DDDUM=AMAX1(ZERO,FLOAT(NY)-DEGFRZ-ZERO)
      PREJ(1)=FISHNI(DDUM*DDDUM/DEGFRZ,DEGFRZ,DDDUM,NOUT)
      PREJ(2)=1.
      IF (DEGFRZ-DEGFRE .GT. .1) PREJ(2)=FISHNI(DDUM*DDDUM/
     1 (DEGFRZ-DEGFRE),DEGFRZ-DEGFRE,DDDUM,NOUT)
 5999 FORMAT (1H1)
  325 IF (NEWPAG) WRITE (33,5999)
      IF (.NOT.HEADNG) GO TO 326
      IF (.NOT.NEWPAG .AND. ILEVEL.NE.2) WRITE (33,5003)
 5003 FORMAT (//1H )
      IF (.NOT.NEWPAG .AND. ILEVEL.EQ.2) WRITE (33,5001)
 5001 FORMAT (1H )
 5300 FORMAT (10X,80A1,10X,31HPRELIMINARY UNWEIGHTED ANALYSIS)
      IF (ISTAGE .EQ. 1) WRITE (33,5300) ITITLE
 5302 FORMAT (10X,80A1)
      IF (ISTAGE .EQ. 2) WRITE (33,5302) ITITLE
 5310 FORMAT (/6X,5HALPHA,4X,10HALPHA/S(1),5X,
     1 10HOBJ. FCTN.,7X,8HVARIANCE,6X,9HSTD. DEV.,4X,11HDEG FREEDOM,4X,
     2 15HPROB1 TO REJECT,4X,15HPROB2 TO REJECT)
      WRITE (33,5310)
 5320 FORMAT (1X,A1,1PE9.2,E14.2,2E15.5,E15.3,0PF15.3,2F19.3)
  326 DDUM=ALPHA/S(1,1)
      DDDUM=ALPHA
      STDDEV=SRANGE
      IF (FLOAT(NY) .GT. DEGFRE) DUB=VAR/(FLOAT(NY)-DEGFRE)
      IF (FLOAT(NY) .GT. DEGFRE) STDDEV=SQRT(DUB)
      IF (PRLDP) WRITE (33,5320) ISTAR(LSTAR),DDDUM,DDUM,VARREG,VAR,
     1 STDDEV,DEGFRE,PREJ
      IF (.NOT.PPLTPR) GO TO 390
C-----------------------------------------------------------------------
C  PUT UNSCALED SOLUTN INTO YLYFIT FOR PLOTTING AND MOMENTS
C-----------------------------------------------------------------------
      DO 327 J=1,NGL
        YLYFIT(J)=SOLUTN(J)*SSCALE(J)
  327 CONTINUE
      DOERR=STDDEV.LT.SRANGE .AND. DEGFRE.GT.0.
      NGLEY=MIN0(NGLE,NY)
      IF (.NOT.DOERR) GO TO 350
C-----------------------------------------------------------------------
C  PUT STANDARD ERRORS OF UNSCALED SOLUTION IN WORK.
C-----------------------------------------------------------------------
      AASCMX=ZERO
      DO 330 J=1,NGL
        DUB=ZERO
        AAMAX=ZERO
        DO 335 K=1,NGLEY
          AAMAX=AMAX1(AAMAX,ABS(AA(J,K)))
          DUB=DUB+AA(J,K)**2
  335   CONTINUE
        WORK(J)=STDDEV*SQRT(DUB)*SSCALE(J)
        AASCMX=AMAX1(AASCMX,AAMAX*SSCALE(J))
  330 CONTINUE
C-----------------------------------------------------------------------
C  PUT SQRT(COVARIANCE MATRIX OF UNSCALED SOLUTION)/(AASCMX) IN AA,
C      AND THEN SCALE STDDEV BY MULTIPLYING IT BY AASCMX.
C-----------------------------------------------------------------------
      DO 340 J=1,NGL
        DUB=SSCALE(J)/AASCMX
        DO 345 K=1,NGLEY
          AA(J,K)=AA(J,K)*DUB
  345   CONTINUE
  340 CONTINUE
      STDDEV=STDDEV*AASCMX
  350 IF (IPRINT(ISTAGE) .GE. ILEVEL) CALL PLPRIN (G,YLYFIT,EXACT,NG,
     1 ONLY1,NOUT,SRANGE,NLINF,NG,NGL,WORK,DOERR)
      IF (IUSROU(ISTAGE) .GE. ILEVEL) CALL USEROU (CQUAD,G,YLYFIT,
     1 EXACT,AA,MG,STDDEV,DOERR,NGLEY)
      IF (.NOT.DOMOM .OR. IPRINT(ISTAGE).LT.ILEVEL) GO TO 390
      J=NGLEY**2+1
      L=MWORK-NGLEY
      K=L-NGLEY
      CALL MOMENT (G,YLYFIT,CQUAD,NG,
     1 MOMNMX(1),MOMNMX(2),NOUT,AA,MG,STDDEV,DOERR,WORK,WORK(J),NGLEY,
     2 MWORK,WORK(K),WORK(L),SRANGE,MPKMOM)
  390 IF (.NOT.SSEARC .OR. VARZ.GE.SRANGE) GO TO 800
C-----------------------------------------------------------------------
C  NORMALLY, RS2MNX(1) SHOULD BE SET IN FIRST SUCCESSFUL ANALYSIS,
C      SINCE PREJ(1)=0 IN THAT CASE.  HOWEVER, IF DEGFRZ=NY, THEN
C      PREJ(1)=1.  IN THIS CASE, RS2MNX(1) IS SET ANYWAY, AND RS2MNX(2)
C      IS NOT SET.
C-----------------------------------------------------------------------
      DDUM=ABS(PREJ(1)+ZERO)
      IF (DDUM .LE. .01) RS2MNX(1)=ALPHA/(PRECIS*S(1,1))
      IF (PREJ(1).GE..995 .AND. RS2MNX(1).GT.0. .AND. RS2MNX(2).LE.0.)
     1 RS2MNX(2)=ALPHA/S(1,1)
      IF (RS2MNX(1) .LE. 0.) RS2MNX(1)=ALPHA/(PRECIS*S(1,1))
      TEST=ABS(PREJ(IICRIT)+ZERO)-PLEVEL(IICRIT,ISTAGE)
C-----------------------------------------------------------------------
C  SOLUTION IS TAKEN AS THE BEST SOLUTION SO FAR IF
C      PREJ.LT.PLEVEL OR IF (PREJ-PLEVEL) IS A MINIMUM SO FAR.
C      HOWEVER, IF ALPHA.LT.ALPBES, THEN IT IS THE MINIMUM IN
C      ABS(PREJ-PLEVEL) THAT IS SOUGHT.
C-----------------------------------------------------------------------
      DUB=TEST
      IF (ALPHA .LT. ALPBES) TEST=ABS(DUB)
      IF (TEST .GE. BTEST) GO TO 800
      BTEST=ABS(DUB)
      ALPBES=ALPHA
      DO 410 J=1,NGL
        SOLBES(J)=SOLUTN(J)
  410 CONTINUE
  800 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE LH1405.  PERFORMS LAWSON AND HANSON, P. 140, STEP 5.
      SUBROUTINE LH1405 (F,M2,M1,E,ME,X)
      DOUBLE PRECISION DUM, E, F, X
      DIMENSION F(1), E(ME,M1), X(M1)
      DO 110 I=1,M2
        DUM=F(I)
        DO 120 J=1,M1
          DUM=DUM-E(I,J)*X(J)
  120   CONTINUE
        F(I)=DUM
  110 CONTINUE
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE MOMENT.  COMPUTES MOMENTS OF Y(J), J=1,N ALONG X-AXIS.
C  MOMENTS OF DEGREE IDEGMN THRU IDEGMX ARE COMPUTED.
C  COMPUTES MOMENTS OVER FULL RANGE J=1,N, AND ALSO OF THE FIRST MPKMOM
C      PEAKS.  IF THERE ARE MORE THAN MPKMOM PEAKS, THEN PEAK MPKMOM
C      AND ALL FOLLOWING PEAKS ARE CONSIDERED TOGETHER AS PEAK MPKMOM.
C  CQUAD ARE THE QUADRATURE COEFFICIENTS FROM SETGRD.
C  RETURNS ARE MADE IF IDEGMX.LT.IDEGMN, OR IF X=0. IS TO BE
C      RAISED TO A NEGATIVE POWER.
C  ABS(Y(J)-Y(J+1)) IS CONSIDERED NEGLIGIBLE AND NOT USED TO
C      DEFINE A PEAK IF IT IS LESS THAN RMIN*YMAX, WHERE YMAX IS THE
C      MAXIMUM OF ABS(Y(J)) AND RMIN IS SET IN THE DATA STATEMENT BELOW.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - ERRMES, MOMOUT
C-----------------------------------------------------------------------
      SUBROUTINE MOMENT (X,Y,CQUAD,N,IDEGMN,IDEGMX,NOUT,
     1 AA,MG,STDDEV,DOERR,W1,W2,NGLEY,MWORK,AMOM1,AMOM2,SRANGE,MPKMOM)
      DOUBLE PRECISION AA, W1, W2, AMOM1, AMOM2
      LOGICAL DOERR
      DIMENSION X(N), Y(N), CQUAD(N), AA(MG,MG), W1(NGLEY,1), W2(1),
     1 AMOM1(1), AMOM2(1)
      DIMENSION IHOLER(6)
      DATA RMIN/1.E-17/, IHOLER/1HM, 1HO, 1HM, 1HE, 1HN, 1HT/
      NM=MIN0(MWORK/NGLEY-3,NGLEY,IDEGMX-IDEGMN+1)
      IDMAX=IDEGMN+NM-1
      IF (NM .LT. 1) RETURN
      IF (.NOT.DOERR) GO TO 105
      IF (STDDEV .LT. 0.) CALL ERRMES (1,.TRUE.,IHOLER,NOUT)
C-----------------------------------------------------------------------
C  TEMPORARILY SCALE THE X VALUES TO HELP AVOID OVERFLOW OR UNDERFLOW.
C-----------------------------------------------------------------------
  105 XMIN=SRANGE
      DO 110 J=1,N
        IF (ABS(X(J)) .GE. XMIN) GO TO 110
        XMIN=ABS(X(J))
        L=J
  110 CONTINUE
C-----------------------------------------------------------------------
C  TAKE SECOND SMALLEST VALUE FOR MIN. IN CASE SMALLEST HAPPENS TO BE
C      NEAR ZERO.
C-----------------------------------------------------------------------
      IF (L .LT. N) XMIN=ABS(X(L+1))
      IF (L .GT. 1) XMIN=AMIN1(XMIN,ABS(X(L-1)))
      IF (XMIN .LE. 0.) CALL ERRMES (2,.TRUE.,IHOLER,NOUT)
      L=1
      IF (ABS(X(1)) .LT. ABS(X(N))) L=N
      XMAX=ABS(X(L))
C-----------------------------------------------------------------------
C  CENTER X ON LOG(X) AXIS.
C-----------------------------------------------------------------------
      XSCALE=1./SQRT(XMIN*XMAX)
C-----------------------------------------------------------------------
C  GUARD AGAINST OVERFLOW OF MAXIMUM TERM.
C-----------------------------------------------------------------------
      IF (IDEGMN.EQ.0 .AND. NM.EQ.1) GO TO 120
      TMXLOG=(.5*ALOG(SRANGE)-ALOG(ABS(FLOAT(N)*CQUAD(L))*
     1 AMAX1(1.,ABS(Y(L)))))/
     2 FLOAT(MAX0(IABS(IDEGMN),IABS(IDMAX)))-ALOG(X(L))
      IF (ALOG(XSCALE) .GT. TMXLOG) XSCALE=EXP(TMXLOG)
  120 XSCLOG=ALOG10(XSCALE)
      DO 130 J=1,N
        X(J)=X(J)*XSCALE
  130 CONTINUE
C-----------------------------------------------------------------------
C  SET PEAK DETECTION THRESHOLD.
C-----------------------------------------------------------------------
      THRESH=0.
      DO 150 J=1,N
        THRESH=AMAX1(THRESH,ABS(Y(J)*CQUAD(J)))
  150 CONTINUE
      THRESH=RMIN*THRESH
C-----------------------------------------------------------------------
C  START OF COMPUTATION OF MOMENTS.
C-----------------------------------------------------------------------
      DO 210 K=1,NM
        AMOM2(K)=0.
        IF (DOERR) W2(K)=0.
  210 CONTINUE
      JYOLD=1
      JY=0
      DLAST=(Y(2)-Y(1))*(ABS(CQUAD(1))+ABS(CQUAD(2)))
      DO 220 JPEAK=1,N
        DO 230 K=1,NM
          AMOM1(K)=0.
          IF (.NOT.DOERR) GO TO 230
          DO 240 J=1,NGLEY
            W1(J,K)=0.
  240     CONTINUE
  230   CONTINUE
  250   JY=JY+1
          IF (IDEGMN.GE.0 .OR. ABS(X(JY)).GT.0.) GO TO 255
          CALL ERRMES (3,.FALSE.,IHOLER,NOUT)
          RETURN
  255     TERM=CQUAD(JY)
          IF (IDEGMN .NE. 0) TERM=TERM*X(JY)**IDEGMN
          DO 260 JDEG=1,NM
            IF (.NOT.DOERR) GO TO 280
            DO 270 J=1,NGLEY
              W1(J,JDEG)=W1(J,JDEG)+TERM*AA(JY,J)
  270       CONTINUE
  280       DUM=TERM*Y(JY)
            AMOM1(JDEG)=AMOM1(JDEG)+DUM
            AMOM2(JDEG)=AMOM2(JDEG)+DUM
            IF (JDEG .LT. NM) TERM=TERM*X(JY)
  260     CONTINUE
          IF (JY .EQ. 1) GO TO 250
          IF (JY .EQ. N) GO TO 300
          DNEXT=(Y(JY+1)-Y(JY))*(ABS(CQUAD(JY))+ABS(CQUAD(JY+1)))
          DUM=DLAST
          IF (ABS(DNEXT) .GT. THRESH) DLAST=DNEXT
          IF (DUM.GE.-THRESH .OR. DNEXT.LE.THRESH .OR. JPEAK.GE.MPKMOM)
     1    GO TO 250
  300   DUM=X(JYOLD)/XSCALE
        DDUM=X(JY)/XSCALE
        WRITE (33,5300) JPEAK,DUM,DDUM
 5300   FORMAT (5H0PEAK,I2,10H GOES FROM,1PE11.3,3H TO,E11.3,
     1   3X,1HJ,9X,9HMOMENT(J),8X,13HPERCENT ERROR,10X,11HM(J)/M(J-1),
     2   3X,13HPERCENT ERROR,4X,1HJ)
        CALL MOMOUT (.FALSE.,AMOM1,
     1  DOERR,IDEGMN,NGLEY,NM,NOUT,STDDEV,W1,W2,XSCALE,XSCLOG)
        JYOLD=JY+1
        IF (JY .LT. N) GO TO 220
        IF (JPEAK .EQ. 1) GO TO 700
        WRITE (33,5310)
 5310   FORMAT (/16X,26HMOMENTS OF ENTIRE SOLUTION,
     1   3X,1HJ,9X,9HMOMENT(J),8X,13HPERCENT ERROR,10X,11HM(J)/M(J-1),
     2   3X,13HPERCENT ERROR,4X,1HJ)
        CALL MOMOUT (.TRUE.,AMOM2,
     1  DOERR,IDEGMN,NGLEY,NM,NOUT,STDDEV,W1,W2,XSCALE,XSCLOG)
        GO TO 700
  220 CONTINUE
C-----------------------------------------------------------------------
C  RESTORE X TO THEIR UNSCALED VALUES.
C-----------------------------------------------------------------------
  700 DO 710 J=1,N
        X(J)=X(J)/XSCALE
  710 CONTINUE
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE MOMOUT.  FOR OUTPUT OF MOMENTS.
C  FULLCV = .TRUE. IF MOMENTS FOR FULL CURVE ARE BEING OUTPUT.
      SUBROUTINE MOMOUT (FULLCV,AMOM,
     1  DOERR,IDEGMN,NGLEY,NM,NOUT,STDDEV,W1,W2,XSCALE,XSCLOG)
      DOUBLE PRECISION AMOM, W1, W2
      LOGICAL FULLCV, DOERR
      DIMENSION AMOM(1), W1(NGLEY,1), W2(1)
      IDEG=IDEGMN-1
      DO 110 JDEG=1,NM
        IDEG=IDEG+1
        IF (JDEG .EQ. 1) GO TO 112
        RMOM=0.
        SAMM1=AMOM(JDEG-1)
        IF (ABS(SAMM1) .GT. 0.) RMOM=AMOM(JDEG)/(AMOM(JDEG-1)*XSCALE)
  112   SAM=AMOM(JDEG)
        IEXP=0
        AMANT=0.
        IF (ABS(SAM) .LE. 0.) GO TO 113
        ANEWLG=ALOG10(ABS(SAM))-FLOAT(IDEG)*XSCLOG
        IEXP=INT(ANEWLG-.5+SIGN(.5,ANEWLG))
        AMANT=SIGN(EXP(2.302585*(ANEWLG-FLOAT(IEXP))),SAM)
  113   PCNEW=0.
        PCRMOM=0.
        IF (.NOT.DOERR .OR. ABS(SAM).LE.0.) GO TO 130
        IF (.NOT.FULLCV) GO TO 115
        ERRMOM=W2(JDEG)
        GO TO 125
  115   ERRMOM=0.
        DO 120 J=1,NGLEY
          ERRMOM=ERRMOM+W1(J,JDEG)**2
  120   CONTINUE
        W2(JDEG)=W2(JDEG)+ERRMOM
  125   PCNEW=100.*STDDEV*SQRT(ERRMOM)/ABS(SAM)
        IF (JDEG .GT. 1) PCRMOM=PCNEW+PCOLD
  130   IF (JDEG .EQ. 1) WRITE (33,5130) IDEG,AMANT,IEXP,PCNEW
        IF (JDEG .GT. 1) WRITE (33,5130) IDEG,AMANT,IEXP,PCNEW,
     1  RMOM,PCRMOM,IDEG
 5130   FORMAT(1X,I45,F10.4,8H X (10**,I4,1H),1PE16.1,E21.4,E16.1,I5)
        PCOLD=PCNEW
  110 CONTINUE
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C     SUBROUTINE NNLS  (A,MDA,M,N,B,X,RNORM,W,ZZ,INDEX,MODE,RANGE)
C     BASED ON C.L.LAWSON AND R.J.HANSON,
C     'SOLVING LEAST SQUARES PROBLEMS', PRENTICE-HALL, 1974
C
C         **********   NONNEGATIVE LEAST SQUARES   **********
C
C     GIVEN AN M BY N MATRIX, A, AND AN M-VECTOR, B,  COMPUTE AN
C     N-VECTOR, X, WHICH SOLVES THE LEAST SQUARES PROBLEM
C
C                      A * X = B  SUBJECT TO X .GE. 0
C
C     A(),MDA,M,N     MDA IS THE FIRST DIMENSIONING PARAMETER FOR THE
C                     ARRAY, A().   ON ENTRY A() CONTAINS THE M BY N
C                     MATRIX, A.           ON EXIT A() CONTAINS
C                     THE PRODUCT MATRIX, Q*A , WHERE Q IS AN
C                     M BY M ORTHOGONAL MATRIX GENERATED IMPLICITLY BY
C                     THIS SUBROUTINE.
C     B()     ON ENTRY B() CONTAINS THE M-VECTOR, B.   ON EXIT B() CON-
C             TAINS Q*B.
C     X()     ON ENTRY X() NEED NOT BE INITIALIZED.  ON EXIT X() WILL
C             CONTAIN THE SOLUTION VECTOR.
C     RNORM   ON EXIT RNORM CONTAINS THE EUCLIDEAN NORM OF THE
C             RESIDUAL VECTOR.
C     W()     AN N-ARRAY OF WORKING SPACE.  ON EXIT W() WILL CONTAIN
C             THE DUAL SOLUTION VECTOR.   W WILL SATISFY W(I) = 0.
C             FOR ALL I IN SET P  AND W(I) .LE. 0. FOR ALL I IN SET Z
C     ZZ()     AN M-ARRAY OF WORKING SPACE.
C     INDEX()     AN INTEGER WORKING ARRAY OF LENGTH AT LEAST N.
C                 ON EXIT THE CONTENTS OF THIS ARRAY DEFINE THE SETS
C                 P AND Z AS FOLLOWS..
C
C                 INDEX(1)   THRU INDEX(NSETP) = SET P.
C                 INDEX(IZ1) THRU INDEX(IZ2)   = SET Z.
C                 IZ1 = NSETP + 1 = NPP1
C                 IZ2 = N
C     MODE    THIS IS A SUCCESS-FAILURE FLAG WITH THE FOLLOWING
C             MEANINGS.
C             1     THE SOLUTION HAS BEEN COMPUTED SUCCESSFULLY.
C             2     THE DIMENSIONS OF THE PROBLEM ARE BAD.
C                   EITHER M .LE. 0 OR N .LE. 0.
C             3    ITERATION COUNT EXCEEDED.  MORE THAN 3*N ITERATIONS.
C
C  RANGE IS 2 OR 3 ORDERS OF MAGNITUDE SMALLER THAN BIG, WHERE BIG IS
C      THE LARGEST NUMBER THAT DOES NOT OVERFLOW AND 1/BIG DOES NOT
C      UNDERFLOW.  FOR THE DOUBLE PRECISION VERSION, BIG AND RANGE
C      ARE IN DOUBLE PRECISION.  FOR THE SINGLE PRECISION VERSION,
C      THEY ARE IN SINGLE PRECISION (AND THEREFORE RANGE=SRANGE).
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - DIFF, H12, G1, G2
C-----------------------------------------------------------------------
      SUBROUTINE NNLS (A,MDA,M,N,B,X,RNORM,W,ZZ,INDEX,MODE,RANGE)
      DOUBLE PRECISION A, ABS, ALPHA, ASAVE, B, CC, DIFF, DUMMY,
     1 FACTOR, RANGE, RNORM, SM, SQRT, SS, T, TWO, UNORM, UP, W,
     2 WMAX, X, ZERO, ZTEST, ZZ
      DIMENSION A(MDA,N), B(1), X(1), W(1), ZZ(1)
      INTEGER INDEX(N)
      ABS(T)=DABS(T)
      SQRT(T)=DSQRT(T)
C     ZERO=0.E0!SP
      ZERO=0.D0
C     TWO=2.E0!SP
      TWO=2.D0
C     FACTOR=1.E-2!SP
      FACTOR=1.D-4
C
      MODE=1
      IF (M.GT.0.AND.N.GT.0) GO TO 10
      MODE=2
      RETURN
   10 ITER=0
      ITMAX=3*N
C
C                    INITIALIZE THE ARRAYS INDEX() AND X().
C
          DO 20 I=1,N
          X(I)=ZERO
   20     INDEX(I)=I
C
      IZ2=N
      IZ1=1
      NSETP=0
      NPP1=1
C                             ******  MAIN LOOP BEGINS HERE  ******
   30 CONTINUE
C                  QUIT IF ALL COEFFICIENTS ARE ALREADY IN THE SOLUTION.
C                        OR IF M COLS OF A HAVE BEEN TRIANGULARIZED.
C
      IF (IZ1.GT.IZ2.OR.NSETP.GE.M) GO TO 350
C
C         COMPUTE COMPONENTS OF THE DUAL (NEGATIVE GRADIENT) VECTOR W().
C
          DO 50 IZ=IZ1,IZ2
          J=INDEX(IZ)
          SM=ZERO
              DO 40 L=NPP1,M
   40         SM=SM+A(L,J)*B(L)
   50     W(J)=SM
C                                   FIND LARGEST POSITIVE W(J).
   60 WMAX=ZERO
          DO 70 IZ=IZ1,IZ2
          J=INDEX(IZ)
          IF (W(J).LE.WMAX) GO TO 70
          WMAX=W(J)
          IZMAX=IZ
   70     CONTINUE
C
C             IF WMAX .LE. 0. GO TO TERMINATION.
C             THIS INDICATES SATISFACTION OF THE KUHN-TUCKER CONDITIONS.
C
      IF (WMAX) 350,350,80
   80 IZ=IZMAX
      J=INDEX(IZ)
C
C     THE SIGN OF W(J) IS OK FOR J TO BE MOVED TO SET P.
C     BEGIN THE TRANSFORMATION AND CHECK NEW DIAGONAL ELEMENT TO AVOID
C     NEAR LINEAR DEPENDENCE.
C
      ASAVE=A(NPP1,J)
      CALL H12 (1,NPP1,NPP1+1,M,A(1,J),1,UP,DUMMY,1,1,0,RANGE)
      UNORM=ZERO
      IF (NSETP.EQ.0) GO TO 100
          DO 90 L=1,NSETP
   90     UNORM=UNORM+A(L,J)**2
      UNORM=SQRT(UNORM)
  100 IF (DIFF(UNORM+ABS(A(NPP1,J))*FACTOR,UNORM)) 130,130,110
C
C     COL J IS SUFFICIENTLY INDEPENDENT.  COPY B INTO ZZ, UPDATE ZZ AND
C   = SOLVE FOR ZTEST ( = PROPOSED NEW VALUE FOR X(J) ).
C
  110     DO 120 L=1,M
  120     ZZ(L)=B(L)
      CALL H12 (2,NPP1,NPP1+1,M,A(1,J),1,UP,ZZ,1,1,1,RANGE)
      ZTEST=ZZ(NPP1)/A(NPP1,J)
C
C                                     SEE IF ZTEST IS POSITIVE
C     REJECT J AS A CANDIDATE TO BE MOVED FROM SET Z TO SET P.
C     RESTORE A(NPP1,J), SET W(J)=0., AND LOOP BACK TO TEST DUAL
C
      IF (ZTEST) 130,130,140
C
C     COEFFS AGAIN.
C
  130 A(NPP1,J)=ASAVE
      W(J)=ZERO
      GO TO 60
C
C     THE INDEX  J=INDEX(IZ)  HAS BEEN SELECTED TO BE MOVED FROM
C     SET Z TO SET P.    UPDATE B,  UPDATE INDICES,  APPLY HOUSEHOLDER
C     TRANSFORMATIONS TO COLS IN NEW SET Z,  ZERO SUBDIAGONAL ELTS IN
C     COL J,  SET W(J)=0.
C
  140     DO 150 L=1,M
  150     B(L)=ZZ(L)
C
      INDEX(IZ)=INDEX(IZ1)
      INDEX(IZ1)=J
      IZ1=IZ1+1
      NSETP=NPP1
      NPP1=NPP1+1
C
      IF (IZ1.GT.IZ2) GO TO 170
          DO 160 JZ=IZ1,IZ2
          JJ=INDEX(JZ)
  160     CALL H12 (2,NSETP,NPP1,M,A(1,J),1,UP,A(1,JJ),1,MDA,1,RANGE)
  170 CONTINUE
C
      IF (NSETP.EQ.M) GO TO 190
          DO 180 L=NPP1,M
  180     A(L,J)=ZERO
  190 CONTINUE
C
      W(J)=ZERO
C                                SOLVE THE TRIANGULAR SYSTEM.
C                                STORE THE SOLUTION TEMPORARILY IN ZZ().
      ASSIGN 200 TO NEXT
      GO TO 400
  200 CONTINUE
C
C                       ******  SECONDARY LOOP BEGINS HERE ******
C
C                          ITERATION COUNTER.
C
  210 ITER=ITER+1
      IF (ITER.LE.ITMAX) GO TO 220
      MODE=3
      GO TO 350
  220 CONTINUE
C
C                    SEE IF ALL NEW CONSTRAINED COEFFS ARE FEASIBLE.
C                                  IF NOT COMPUTE ALPHA.
C
      ALPHA=TWO
          DO 240 IP=1,NSETP
          L=INDEX(IP)
          IF (ZZ(IP)) 230,230,240
C
  230     T=-X(L)/(ZZ(IP)-X(L))
          IF (ALPHA.LE.T) GO TO 240
          ALPHA=T
          JJ=IP
  240     CONTINUE
C
C          IF ALL NEW CONSTRAINED COEFFS ARE FEASIBLE THEN ALPHA WILL
C          STILL = 2.    IF SO EXIT FROM SECONDARY LOOP TO MAIN LOOP.
C
      IF (ALPHA.EQ.TWO) GO TO 330
C
C          OTHERWISE USE ALPHA WHICH WILL BE BETWEEN 0. AND 1. TO
C          INTERPOLATE BETWEEN THE OLD X AND THE NEW ZZ.
C
          DO 250 IP=1,NSETP
          L=INDEX(IP)
  250     X(L)=X(L)+ALPHA*(ZZ(IP)-X(L))
C
C        MODIFY A AND B AND THE INDEX ARRAYS TO MOVE COEFFICIENT I
C        FROM SET P TO SET Z.
C
      I=INDEX(JJ)
  260 X(I)=ZERO
C
      IF (JJ.EQ.NSETP) GO TO 290
      JJ=JJ+1
          DO 280 J=JJ,NSETP
          II=INDEX(J)
          INDEX(J-1)=II
          CALL G1 (A(J-1,II),A(J,II),CC,SS,A(J-1,II))
          A(J,II)=ZERO
              DO 270 L=1,N
              IF (L.NE.II) CALL G2 (CC,SS,A(J-1,L),A(J,L))
  270         CONTINUE
  280     CALL G2 (CC,SS,B(J-1),B(J))
  290 NPP1=NSETP
      NSETP=NSETP-1
      IZ1=IZ1-1
      INDEX(IZ1)=I
C
C        SEE IF THE REMAINING COEFFS IN SET P ARE FEASIBLE.  THEY SHOULD
C        BE BECAUSE OF THE WAY ALPHA WAS DETERMINED.
C        IF ANY ARE INFEASIBLE IT IS DUE TO ROUND-OFF ERROR.  ANY
C        THAT ARE NONPOSITIVE WILL BE SET TO ZERO
C        AND MOVED FROM SET P TO SET Z.
C
          DO 300 JJ=1,NSETP
          I=INDEX(JJ)
          IF (X(I)) 260,260,300
  300     CONTINUE
C
C         COPY B( ) INTO ZZ( ).  THEN SOLVE AGAIN AND LOOP BACK.
C
          DO 310 I=1,M
  310     ZZ(I)=B(I)
      ASSIGN 320 TO NEXT
      GO TO 400
  320 CONTINUE
      GO TO 210
C                      ******  END OF SECONDARY LOOP  ******
C
  330     DO 340 IP=1,NSETP
          I=INDEX(IP)
  340     X(I)=ZZ(IP)
C        ALL NEW COEFFS ARE POSITIVE.  LOOP BACK TO BEGINNING.
      GO TO 30
C
C                        ******  END OF MAIN LOOP  ******
C
C                        COME TO HERE FOR TERMINATION.
C                     COMPUTE THE NORM OF THE FINAL RESIDUAL VECTOR.
C
  350 SM=ZERO
      IF (NPP1.GT.M) GO TO 370
          DO 360 I=NPP1,M
  360     SM=SM+B(I)**2
      GO TO 390
  370     DO 380 J=1,N
  380     W(J)=ZERO
  390 RNORM=SQRT(SM)
      RETURN
C
C     THE FOLLOWING BLOCK OF CODE IS USED AS AN INTERNAL SUBROUTINE
C     TO SOLVE THE TRIANGULAR SYSTEM, PUTTING THE SOLUTION IN ZZ().
C
  400     DO 430 L=1,NSETP
          IP=NSETP+1-L
          IF (L.EQ.1) GO TO 420
              DO 410 II=1,IP
  410         ZZ(II)=ZZ(II)-A(II,JJ)*ZZ(IP+1)
  420     JJ=INDEX(IP)
  430     ZZ(IP)=ZZ(IP)/A(IP,JJ)
      GO TO NEXT, (200,320)
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  FUNCTION PGAUSS.  CALCULATES AREA UNDER NORMAL CURVE (CENTERED
C      AT 0 WITH UNIT VARIANCE) FROM -(INFINITY) TO X USING
C      ABRAMOWITZ AND STEGUN, EQ. 26.2.18.
C  ABS(ERROR) .LT. 2.5E-4
      FUNCTION PGAUSS (X)
      AX=ABS(X)
      PGAUSS=1.+AX*(.196854+AX*(.115194+AX*(3.44E-4+AX*.019527)))
      PGAUSS=1./PGAUSS**2
      PGAUSS=.5*PGAUSS**2
      IF (X .GT. 0.) PGAUSS=1.-PGAUSS
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE PLPRIN.  PLOTS Y1 (AND Y2, IF ONLY1=.FALSE.) VS. X ON
C      LINE PRINTER, AND PRINTS Y1 AND X.
C  IF PLTERR=T, AN ERROR BAND IS ALSO PLOTTED USING THE ERRORS
C      SUPPLIED IN YERR.
C  IF NLINF.GT.0, THEN THE NLINF LINEAR COEFFICIENTS Y(J), J=NG+1,MY1
C      ARE PRINTED OUT.  IN THIS CASE MY1=NGL NORMALLY.
      SUBROUTINE PLPRIN (X,Y1,Y2,N,ONLY1,NOUT,SRANGE,NLINF,NG,MY1,
     1 YERR, PLTERR)
      DOUBLE PRECISION YERR, DUB
      LOGICAL ONLY1, PLTERR
      DIMENSION X(1), Y1(1), Y2(1), ICHAR(5), IH(109), YERR(1)
      DATA ICHAR/1H , 1HX, 1HO, 1H*, 1H./
C     SINGLE(DUB)=DUB!SP
      SINGLE(DUB)=SNGL(DUB)
      DUB=1.D0
      YMIN=SRANGE
      YMAX=-SRANGE
      JINC=1
      DO 120 J=1,N
        YMIN=AMIN1(YMIN,Y1(J))
        YMAX=AMAX1(YMAX,Y1(J))
        IF (ONLY1) GO TO 120
        YMIN=AMIN1(YMIN,Y2(J))
        YMAX=AMAX1(YMAX,Y2(J))
  120 CONTINUE
      DUM=YMAX-YMIN
      NCHAR=109
      IF (DUM .LE. FLOAT(NCHAR)/SRANGE) DUM=1.
      IF (PLTERR) GO TO 130
      WRITE (33,5120)
 5120 FORMAT (/4X,8HORDINATE,2X,8HABSCISSA)
      GO TO 140
  130 NCHAR=100
 5130 FORMAT (/4X,8HORDINATE,4X,5HERROR,2X,8HABSCISSA)
      WRITE (33,5130)
  140 R=(FLOAT(NCHAR)-.001)/DUM
      IF (N .LE. 120) GO TO 145
      RINC=FLOAT(N)/120.
      JINC=INT(RINC)
  145 CONTINUE
      REWIND 82
      DO 150 J=1,N,JINC
        DO 155 L1=1,NCHAR
          IH(L1)=ICHAR(1)
  155   CONTINUE
        IF (.NOT.PLTERR) GO TO 158
        LMIN=INT((AMAX1(YMIN,Y1(J)-ABS(SINGLE(YERR(J))))-YMIN)*R)+1
        LMAX=INT((AMIN1(YMAX,Y1(J)+ABS(SINGLE(YERR(J))))-YMIN)*R)+1
        IF (LMIN .GE. LMAX) GO TO 158
        DO 156 L1=LMIN,LMAX
          IH(L1)=ICHAR(5)
  156   CONTINUE
  158   L1=INT((Y1(J)-YMIN)*R)+1
        IH(L1)=ICHAR(2)
        IF (ONLY1) GO TO 160
        L2=INT((Y2(J)-YMIN)*R)+1
        IH(L2)=ICHAR(3)
        IF (L1 .EQ. L2) IH(L2)=ICHAR(4)
  160   IF (.NOT.PLTERR) WRITE (33,5160) Y1(J),X(J),IH
 5160   FORMAT (1X,1PE11.3,E10.2,109A1)
        IF (PLTERR) WRITE (33,5161) Y1(J),YERR(J),X(J),
     1  (IH(L1),L1=1,NCHAR)
        IF (PLTERR)THEN
C         WRITE (82, 9161)J, Y1(J),YERR(J),X(J)
         WRITE (82, 9162) X(J), Y1(J), YERR(J)
        END IF
 9161   FORMAT(I5, 3F22.8)
 9162   FORMAT(3F16.8)
C5161   FORMAT (1X,1PE11.3,E9.1,E10.2,100A1)!SP
 5161   FORMAT (1X,1PE11.3,D9.1,E10.2,100A1)
  150 CONTINUE
      IF (NLINF .LE. 0) GO TO 800
      L2=NG+1
 5200 FORMAT (22H0LINEAR COEFFICIENTS =,1P,8E13.4/(22X,8E13.4))
      IF (.NOT.PLTERR) WRITE (33,5200) (Y1(J),J=L2,MY1)
      IF (PLTERR) WRITE(33,5201) (Y1(J),YERR(J),J=L2,MY1)
C5201 FORMAT (22H0LINEAR COEFFICIENTS =,!SP
C    1 1PE13.4,3H +-,E9.1,E20.4,3H +-,E9.1,E20.4,3H +-,E9.1/!SP
C    2 (22X,1PE13.4,3H +-,E9.1,E20.4,3H +-,E9.1,E20.4,3H +-,E9.1))!SP
 5201 FORMAT (22H0LINEAR COEFFICIENTS =,
     1 1PE13.4,3H +-,D9.1,E20.4,3H +-,D9.1,E20.4,3H +-,D9.1/
     2 (22X,1PE13.4,3H +-,D9.1,E20.4,3H +-,D9.1,E20.4,3H +-,D9.1))
  800 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE PLRES. PLOTS RESIDUALS ON PRINTER WITH X-AXIS HORIZONTAL.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - ERRMES
C-----------------------------------------------------------------------
      SUBROUTINE PLRES (YLYFIT,NMAX,N,PRUNS,PUNCOR,RALPS1,NOUT,LINEPG,
     1 ITITLE,CHOSEN)
      LOGICAL CHOSEN
      DIMENSION YLYFIT(NMAX), JCHAR(8), LINE(131), LABEL(6), BOUND(21),
     1 LCHARJ(20), LINE1(20), IHOLER(6), ITITLE(80), PUNCOR(5)
      DATA JCHAR/1H*, 1H-, 1HU, 1HL, 1H , 1H0, 1H-, 1H+/,
     1 IHOLER/1HP, 1HL, 1HR, 1HE, 1HS, 1H /, MPAGE/30/
      IF (LINEPG .GE. 17) GO TO 100
      CALL ERRMES (1,.FALSE.,IHOLER,NOUT)
      RETURN
  100 MPLOT=(LINEPG-3)/16
      MLINE=MIN0(20,(LINEPG-3)/MPLOT-3)
      RMIN=YLYFIT(1)
      RMAX=YLYFIT(1)
 5910 FORMAT(I5, 2F20.8)
      DO 110 J=1,N
      WRITE(11, 5910)J,YLYFIT(J)
      RMIN=AMIN1(RMIN,YLYFIT(J))
  110 RMAX=AMAX1(RMAX,YLYFIT(J))
 5110 FORMAT (1H1,9X,80A1)
      IF (.NOT.CHOSEN) WRITE(33,5110) ITITLE
 5200 FORMAT (/
     1 32H WEIGHTED RESIDUALS (ALPHA/S(1)=,
     2 1PE9.2,8H) MAX=U=,E8.1,2X,6HMIN=L=,E8.1,1X,
     3 7H(PRUNS=,0PF7.4,9H) PUNCOR=,5F7.4)
      WRITE (33,5200) RALPS1,RMAX,RMIN,PRUNS,PUNCOR
      DELTA=(RMAX-RMIN)/FLOAT(MLINE-1)
      BOUND(1)=RMAX+.5*DELTA
      K=MLINE+1
      DO 120 J=2,K
      BOUND(J)=BOUND(J-1)-DELTA
  120 IF (BOUND(J)*BOUND(J-1) .LT. 0.) JAXIS=J-1
      LABEL(1)=-110
      DO 130 J=2,6
  130 LABEL(J)=LABEL(J-1)+20
      K=MLINE-1
      DO 140 J=2,K
      LINE1(J)=JCHAR(5)
  140 LCHARJ(J)=5
      LINE1(1)=JCHAR(3)
      LINE1(JAXIS)=JCHAR(6)
      LINE1(MLINE)=JCHAR(4)
      LCHARJ(1)=7
      LCHARJ(JAXIS)=2
      LCHARJ(MLINE)=7
      NPOINT=0
      DO 200 NPAGE=1,MPAGE
      IF (NPAGE .GT. 1) WRITE(  33,5999)
 5999 FORMAT (1H1)
      DO 210 NPLOT=1,MPLOT
 5001 FORMAT (1H )
      WRITE (33,5001)
      NST=NPOINT+1
      NEND=NPOINT+130
      NPOINT=NEND
      NLIM=MIN0(NEND,N)
      DO 220 NLINE=1,MLINE
      LCHAR=LCHARJ(NLINE)
      LINE(1)=LINE1(NLINE)
      BMAX=BOUND(NLINE)
      BMIN=BOUND(NLINE+1)
      K=1
      DO 230 J=NST,NLIM
      K=K+1
      LINE(K)=JCHAR(LCHAR)
      IF (YLYFIT(J).LT.BMAX .AND. YLYFIT(J).GE.BMIN) LINE(K)=JCHAR(1)
  230 CONTINUE
      K=NLIM-NST+2
      IF (NLINE.NE.1 .AND. NLINE.NE.MLINE) GO TO 235
      DO 232 J=11,K,10
  232 IF (LINE(J) .NE. JCHAR(1)) LINE(J)=JCHAR(8)
 5230 FORMAT (1X,A1,130A1)
  235 WRITE (  33,5230) (LINE(J),J=1,K)
  220 CONTINUE
      DO 240 J=1,6
  240 LABEL(J)=LABEL(J)+130
 5240 FORMAT (3X,6(16X,I4)/)
      WRITE (  33,5240) LABEL
      IF (NLIM .EQ. N) RETURN
  210 CONTINUE
  200 CONTINUE
      CALL ERRMES (2,.FALSE.,IHOLER,NOUT)
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C     SUBROUTINE QRBD (IPASS,Q,E,NN,V,MDV,NRV,C,MDC,NCC,RANGE)
C     BASED ON C.L.LAWSON AND R.J.HANSON,
C     'SOLVING LEAST SQUARES PROBLEMS', PRENTICE-HALL, 1974
C          QR ALGORITHM FOR SINGULAR VALUES OF A BIDIAGONAL MATRIX.
C
C     THE BIDIAGONAL MATRIX
C
C                       (Q1,E2,0...    )
C                       (   Q2,E3,0... )
C                D=     (       .      )
C                       (         .   0)
C                       (           .EN)
C                       (          0,QN)
C
C                 IS PRE AND POST MULTIPLIED BY
C                 ELEMENTARY ROTATION MATRICES
C                 RI AND PI SO THAT
C
C                 RK...R1*D*P1**(T)...PK**(T) = DIAG(S1,...,SN)
C
C                 TO WITHIN WORKING ACCURACY.
C
C  1. EI AND QI OCCUPY E(I) AND Q(I) AS INPUT.
C
C  2. RM...R1*C REPLACES 'C' IN STORAGE AS OUTPUT.
C
C  3. V*P1**(T)...PM**(T) REPLACES 'V' IN STORAGE AS OUTPUT.
C
C  4. SI OCCUPIES Q(I) AS OUTPUT.
C
C  5. THE SI'S ARE NONINCREASING AND NONNEGATIVE.
C
C     THIS CODE IS BASED ON THE PAPER AND 'ALGOL' CODE..
C REF..
C  1. REINSCH,C.H. AND GOLUB,G.H. 'SINGULAR VALUE DECOMPOSITION
C     AND LEAST SQUARES SOLUTIONS' (NUMER. MATH.), VOL. 14,(1970).
C
C  RANGE IS 2 OR 3 ORDERS OF MAGNITUDE SMALLER THAN BIG, WHERE BIG IS
C      THE LARGEST NUMBER THAT DOES NOT OVERFLOW AND 1/BIG DOES NOT
C      UNDERFLOW.  FOR THE DOUBLE PRECISION VERSION, BIG AND RANGE
C      ARE IN DOUBLE PRECISION.  FOR THE SINGLE PRECISION VERSION,
C      THEY ARE IN SINGLE PRECISION (AND THEREFORE RANGE=SRANGE).
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - G1, G2, DIFF
C-----------------------------------------------------------------------
      SUBROUTINE QRBD (IPASS,Q,E,NN,V,MDV,NRV,C,MDC,NCC,RANGE)
      DOUBLE PRECISION ABS, AMAX1, C, CS, DENOM, DIFF, DNORM, E, F,
     A G, H, ONE, Q, RANGE,
     1 RNUMER, SN, SQRT, SQRTRG, T, TWO, V, X, Y, Z, ZERO
      LOGICAL WNTV, HAVERS, FAIL, LDUM
      DIMENSION Q(NN),E(NN),V(MDV,1),C(MDC,1)
      AMAX1(ZERO,ONE)=DMAX1(ZERO,ONE)
      ABS(ONE)=DABS(ONE)
      SQRT(ONE)=DSQRT(ONE)
C     ZERO=0.E0!SP
      ZERO=0.D0
C     ONE=1.E0!SP
      ONE=1.D0
C     TWO=2.E0!SP
      TWO=2.D0
      SQRTRG=SQRT(RANGE)
C
      N=NN
      IPASS=1
      IF (N.LE.0) RETURN
      N10=10*N
      WNTV=NRV.GT.0
      HAVERS=NCC.GT.0
      FAIL=.FALSE.
      NQRS=0
      E(1)=ZERO
      DNORM=ZERO
           DO 10 J=1,N
   10      DNORM=AMAX1(ABS(Q(J))+ABS(E(J)),DNORM)
           DO 200 KK=1,N
           K=N+1-KK
C
C     TEST FOR SPLITTING OR RANK DEFICIENCIES..
C         FIRST MAKE TEST FOR LAST DIAGONAL TERM, Q(K), BEING SMALL.
   20       IF(K.EQ.1) GO TO 50
            IF(DIFF(DNORM+Q(K),DNORM)) 50,25,50
C
C     SINCE Q(K) IS SMALL WE WILL MAKE A SPECIAL PASS TO
C     TRANSFORM E(K) TO ZERO.
C
   25      CS=ZERO
           SN=-ONE
                DO 40 II=2,K
                I=K+1-II
                F=-SN*E(I+1)
                E(I+1)=CS*E(I+1)
                CALL G1 (Q(I),F,CS,SN,Q(I))
C         TRANSFORMATION CONSTRUCTED TO ZERO POSITION (I,K).
C
                IF (.NOT.WNTV) GO TO 40
                     DO 30 J=1,NRV
   30                CALL G2 (CS,SN,V(J,I),V(J,K))
C              ACCUMULATE RT. TRANSFORMATIONS IN V.
C
   40           CONTINUE
C
C         THE MATRIX IS NOW BIDIAGONAL, AND OF LOWER ORDER
C         SINCE E(K) .EQ. ZERO..
C
   50           DO 60 LL=1,K
                L=K+1-LL
                IF(DIFF(DNORM+E(L),DNORM)) 55,100,55
   55           IF(DIFF(DNORM+Q(L-1),DNORM)) 60,70,60
   60           CONTINUE
C     THIS LOOP CAN'T COMPLETE SINCE E(1) = ZERO.
C
           GO TO 100
C
C         CANCELLATION OF E(L), L.GT.1.
   70      CS=ZERO
           SN=-ONE
                DO 90 I=L,K
                F=-SN*E(I)
                E(I)=CS*E(I)
                IF(DIFF(DNORM+F,DNORM)) 75,100,75
   75           CALL G1 (Q(I),F,CS,SN,Q(I))
                IF (.NOT.HAVERS) GO TO 90
                     DO 80 J=1,NCC
   80                CALL G2 (CS,SN,C(I,J),C(L-1,J))
   90           CONTINUE
C
C         TEST FOR CONVERGENCE..
  100      Z=Q(K)
           IF (L.EQ.K) GO TO 170
C
C         SHIFT FROM BOTTOM 2 BY 2 MINOR OF B**(T)*B.
           X=Q(L)
           Y=Q(K-1)
           G=E(K-1)
           H=E(K)
C-----------------------------------------------------------------------
C  TO PREVENT ZERO-DIVIDE, TEST DENOMINATOR.
C-----------------------------------------------------------------------
           RNUMER=(Y-Z)*(Y+Z)+(G-H)*(G+H)
           DENOM=TWO*H*Y
           LDUM=ABS(DENOM) .LE. ZERO
           IF (LDUM) F=.5*RANGE
           IF (.NOT.LDUM) F=RNUMER/DENOM
C-----------------------------------------------------------------------
C  TO HELP PREVENT OVERFLOW, SET G=ABS(F) FOR VERY LARGE F.
C-----------------------------------------------------------------------
           G=ABS(F)
           IF (G .LT. SQRTRG) G=SQRT(ONE+G**2)
           IF (F.LT.ZERO) GO TO 110
           T=F+G
           GO TO 120
  110      T=F-G
  120      F=((X-Z)*(X+Z)+H*(Y/T-H))/X
C
C         NEXT QR SWEEP..
           CS=ONE
           SN=ONE
           LP1=L+1
                DO 160 I=LP1,K
                G=E(I)
                Y=Q(I)
                H=SN*G
                G=CS*G
                CALL G1 (F,H,CS,SN,E(I-1))
                F=X*CS+G*SN
                G=-X*SN+G*CS
                H=Y*SN
                Y=Y*CS
                IF (.NOT.WNTV) GO TO 140
C
C              ACCUMULATE ROTATIONS (FROM THE RIGHT) IN 'V'
                     DO 130 J=1,NRV
  130                CALL G2 (CS,SN,V(J,I-1),V(J,I))
  140           CALL G1 (F,H,CS,SN,Q(I-1))
                F=CS*G+SN*Y
                X=-SN*G+CS*Y
                IF (.NOT.HAVERS) GO TO 160
                     DO 150 J=1,NCC
  150                CALL G2 (CS,SN,C(I-1,J),C(I,J))
C              APPLY ROTATIONS FROM THE LEFT TO
C              RIGHT HAND SIDES IN 'C'..
C
  160           CONTINUE
           E(L)=ZERO
           E(K)=F
           Q(K)=X
           NQRS=NQRS+1
           IF (NQRS.LE.N10) GO TO 20
C          RETURN TO 'TEST FOR SPLITTING'.
C
           FAIL=.TRUE.
C     ..
C     CUTOFF FOR CONVERGENCE FAILURE. 'NQRS' WILL BE 2*N USUALLY.
  170      IF (Z.GE.ZERO) GO TO 190
           Q(K)=-Z
           IF (.NOT.WNTV) GO TO 190
                DO 180 J=1,NRV
  180           V(J,K)=-V(J,K)
  190      CONTINUE
C         CONVERGENCE. Q(K) IS MADE NONNEGATIVE..
C
  200      CONTINUE
      IF (N.EQ.1) RETURN
           DO 210 I=2,N
           IF (Q(I).GT.Q(I-1)) GO TO 220
  210      CONTINUE
      IF (FAIL) IPASS=2
      RETURN
C     ..
C     EVERY SINGULAR VALUE IS IN ORDER..
  220      DO 270 I=2,N
           T=Q(I-1)
           K=I-1
                DO 230 J=I,N
                IF (T.GE.Q(J)) GO TO 230
                T=Q(J)
                K=J
  230           CONTINUE
           IF (K.EQ.I-1) GO TO 270
           Q(K)=Q(I-1)
           Q(I-1)=T
           IF (.NOT.HAVERS) GO TO 250
                DO 240 J=1,NCC
                T=C(I-1,J)
                C(I-1,J)=C(K,J)
  240           C(K,J)=T
  250      IF (.NOT.WNTV) GO TO 270
                DO 260 J=1,NRV
                T=V(J,I-1)
                V(J,I-1)=V(J,K)
  260           V(J,K)=T
  270      CONTINUE
C         END OF ORDERING ALGORITHM.
C
      IF (FAIL) IPASS=2
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  FUNCTION RANDOM.  PRODUCES A PSEUDORANDOM REAL ON THE OPEN INTERVAL
C      (0.,1.).
C  DIX (IN DOUBLE PRECISION) MUST BE INITIALIZED TO A WHOLE NUMBER
C      BETWEEN 1.D0 AND 2147483646.D0 BEFORE THE FIRST CALL TO RANDOM
C      AND NOT CHANGED BETWEEN SUCCESSIVE CALLS TO RANDOM.
C  BASED ON L. SCHRAGE, ACM TRANS. ON MATH. SOFTWARE 5, 132 (1979).
C-----------------------------------------------------------------------
      FUNCTION RANDOM(DIX)
C
C  PORTABLE RANDOM NUMBER GENERATOR
C   USING THE RECURSION
C    DIX = DIX*A MOD P
C
      DOUBLE PRECISION A,P,DIX,B15,B16,XHI,XALO,LEFTLO,FHI,K
C
C  7**5, 2**15, 2**16, 2**31-1
      DATA A/16807.D0/,B15/32768.D0/,B16/65536.D0/,P/2147483647.D0/
C
C  GET 15 HI ORDER BITS OF DIX
      XHI = DIX / B16
      XHI = XHI - DMOD(XHI,1.D0)
C  GET 16 LO BITS IF DIX AND FORM LO PRODUCT
      XALO=(DIX-XHI*B16)*A
C  GET 15 HI ORDER BITS OF LO PRODUCT
      LEFTLO = XALO/B16
      LEFTLO = LEFTLO - DMOD(LEFTLO,1.D0)
C  FORM THE 31 HIGHEST BITS OF FULL PRODUCT
      FHI = XHI*A + LEFTLO
C  GET OVERFLO PAST 31ST BIT OF FULL PRODUCT
      K = FHI/B15
      K = K - DMOD(K,1.D0)
C  ASSEMBLE ALL THE PARTS AND PRESUBTRACT P
C   THE PARENTHESES ARE ESSENTIAL
      DIX = (((XALO-LEFTLO*B16) - P) + (FHI-K*B15)*B16) + K
C  ADD P BACK IN IF NECESSARY
      IF (DIX .LT. 0.D0) DIX = DIX + P
C  MULTIPLY BY 1/(2**31-1)
      RANDOM=DIX*4.656612875D-10
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE READYT.  READS Y(J) (INPUT DATA), T(J) (INDEPENDENT
C      VARIABLE), AND, IF IWT=4, LEAST SQUARES WEIGHTS, FOR J=1,NY.
C  IF DOUSIN=.TRUE., THEN USERIN IS CALLED TO RECOMPUTE OR CHANGE
C      INPUT DATA.
C-----------------------------------------------------------------------
C  CALL SUBPROGRAMS - USERIN, ERRMES
C-----------------------------------------------------------------------
      SUBROUTINE READYT (MY,NIOERR,SQRTW,T,Y)
      DOUBLE PRECISION PRECIS, RANGE
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      DIMENSION SQRTW(MY), T(MY), Y(MY)
      DIMENSION LIN(6), LA(6,2), IHOLER(6)
      DIMENSION LY(8)
      CHARACTER abc
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
      DATA IHOLER/1HR, 1HE, 1HA, 1HD, 1HY, 1HT/, LA/
     1 1HN, 1HS, 1HT, 1HE, 1HN, 1HD,   1HN, 1HY, 4*1H /
      IF (NINTT .LE. 0) GO TO 200
C-----------------------------------------------------------------------
C  COMPUTE T IN EQUAL INTERVALS.
C-----------------------------------------------------------------------
      NY=0
      DO 110 J=1,NINTT
 5110 FORMAT (1X,6A1,I5,2E15.6)
      READ (NIN,5110) LIN,NT,TSTART,TEND
 5120 FORMAT (1X,6A1,I5,1P,2E15.5)
      WRITE (33,5120) LIN,NT,TSTART,TEND
      DO 120 K=1,6
        IF (LIN(K) .NE. LA(K,1)) GO TO 130
  120 CONTINUE
      GO TO 140
  130 CALL ERRMES (1,.FALSE.,IHOLER,NOUT)
      GO TO 190
  140 IF (NT.GE.2 .AND. NT+NY.LE.MY) GO TO 150
      CALL ERRMES (2,.FALSE.,IHOLER,NOUT)
      GO TO 190
  150 DUM=(TEND-TSTART)/FLOAT(NT-1)
      NY=NY+1
      T(NY)=TSTART
      DO 160 K=2,NT
      NY=NY+1
  160 T(NY)=T(NY-1)+DUM
      GO TO 110
  190 NIOERR=NIOERR+1
      IF (NIOERR .GE. MIOERR) STOP
  110 CONTINUE
      GO TO 300
C-----------------------------------------------------------------------
C  READ IN NY AND THEN T ARRAY.
C-----------------------------------------------------------------------
  200 READ (NIN,5110) LIN,NY
      WRITE (33,5110) LIN,NY
      DO 210 K=1,6
        IF (LIN(K) .NE. LA(K,2)) GO TO 220
  210 CONTINUE
      GO TO 230
  220 CALL ERRMES (3,.FALSE.,IHOLER,NOUT)
      GO TO 235
  230 IF (NY .LE. MY) GO TO 240
      CALL ERRMES (4,.FALSE.,IHOLER,NOUT)
  235 NIOERR=NIOERR+1
      RETURN
  240 READ (NIN,IFORMT) (T(J),J=1,NY)
C-----------------------------------------------------------------------
C  READ IN Y ARRAY.
C-----------------------------------------------------------------------
  300 IF (.NOT.SIMULA) THEN
        READ (55, '(A)') abc
        READ (55,IFORMY) (Y(J),J=1,NY)
      ENDIF
 1055 FORMAT(1X, 9I7)
      IF (IWT .EQ. 4) GO TO 420
C-----------------------------------------------------------------------
C  INITIALIZE SQRTW (SQUARE ROOTS OF LEAST SQUARES WEIGHTS) TO UNITY.
C-----------------------------------------------------------------------
      DO 410 J=1,NY
      SQRTW(J)=1.
  410 CONTINUE
C-----------------------------------------------------------------------
C  READ IN LEAST SQUARES WEIGHTS IF IWT=4.
C-----------------------------------------------------------------------
  420 IF (IWT .EQ. 4) READ (NIN,IFORMW) (SQRTW(J),J=1,NY)
C-----------------------------------------------------------------------
C  READ IN REFERENCE DATA IF IUSER(10)=5 OR 6.
C-----------------------------------------------------------------------
      IF ((IUSER(10) .EQ. 5).OR.(IUSER(10) .EQ. 6)) THEN
        READ (56, '(A)') abc
        READ (56 ,IFORMY) (YREF(J),J=1,NY)
      ENDIF
C-----------------------------------------------------------------------
C  CALL USERIN TO CHANGE OR RECOMPUTE INPUT DATA.
C-----------------------------------------------------------------------
      IF (DOUSIN) CALL USERIN (T,Y,SQRTW,MY)
      DO 430 J=1,NY
      IF (SQRTW(J) .GE. 0.) GO TO 440
      CALL ERRMES (5,.FALSE.,IHOLER,NOUT)
 5440 FORMAT (1X,1P,10E13.5)
      WRITE (33,5440) (SQRTW(K),K=1,NY)
      NIOERR=NIOERR+1
      GO TO 800
  440 SQRTW(J)=SQRT(SQRTW(J))
  430 CONTINUE
  800 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE RGAUSS.  AN EXACT METHOD FOR GENERATING X1 AND X2, TWO
C      STANDARD (ZERO MEAN, UNIT VARIANCE) NORMAL RANDOM DEVIATES
C      FROM 2 CALLS TO RANDOM, WHICH DELIVERS A UNIFORM RANDOM
C      DEVIATE ON THE INTERVAL (0,1).  (SEE M. C. PIKE,
C      ALGORITHM 267 FROM CACM)
C  TWOPI = 2.*PI.
C  DIX IS EXPLAINED IN THE COMMENTS IN RANDOM.
C  IF A VERY LARGE NUMBER OF DEVIATES ARE TO BE GENERATED,
C      FASTER ROUTINES EXIST.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - RANDOM
C-----------------------------------------------------------------------
      SUBROUTINE RGAUSS (X1,X2,TWOPI,DIX)
      DOUBLE PRECISION DIX
      X1=SQRT(-2.*ALOG(RANDOM(DIX)))
      DUM=TWOPI*RANDOM(DIX)
      X2=X1*SIN(DUM)
      X1=X1*COS(DUM)
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE RUNRES.  COMPUTES PRUNS (RUNS TEST PROBABILITY) AND
C      PUNCOR (AUTOCORRELATION TEST PROBABILITIES) FOR SOL(J), J=1,NY.
C  IF ILEVEL.LE.IPLRES(ISTAGE), THEN RESIDUALS ARE PLOTTED.
C  IF ILEVEL.LE.IPLFIT(ISTAGE), THEN Y (DATA) AND
C      YFIT (FIT TO DATA) ARE PLOTTED.
C  IF NEWPAG=.TRUE., THEN A NEW PAGE IS STARTED.
C  RALPS1 = ALPHA/(LARGEST SINGULAR VALUE).
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - GETPRU, PLRES, PLPRIN
C  WHICH IN TURN CALL - PGAUSS, GETYLY, GETROW, USERK, USERLF, ERRMES,
C      BETAIN, FISHNI, GAMLN, USERTR
C-----------------------------------------------------------------------
      SUBROUTINE RUNRES (ILEVEL,SOL,NEWPAG,RALPS1,CHOSEN,
     1 CQUAD,G,IPLFIT,IPLRES,ISTAGE,ITITLE,IUNIT,IWT,LINEPG,MWORK,NG,
     2 NGL,NLINF,NOUT,NY,SQRTW,SRANGE,SSCALE,T,WORK,Y,YLYFIT)
      DOUBLE PRECISION  SOL, SSCALE, WORK
      LOGICAL NEWPAG, CHOSEN
      DIMENSION SOL(NGL), WORK(MWORK), SQRTW(NY), CQUAD(NG), G(NG),
     1 SSCALE(NGL), T(NY), Y(NY), YLYFIT(NY), ITITLE(80), IPLFIT(2),
     2 IPLRES(2)
      DIMENSION PUNCOR(5)
      CALL GETPRU (SOL,
     1 CQUAD,G,IUNIT,IWT,MWORK,NG,NGL,NLINF,NOUT,NY,PRUNS,PUNCOR,SQRTW,
     2 SSCALE,T,WORK,Y,YLYFIT)
      IF (ILEVEL .LE. IPLRES(ISTAGE)) GO TO 150
 5100 FORMAT (1H1,9X,80A1)
      IF (NEWPAG) WRITE (33,5100) ITITLE
 5110 FORMAT (18H0(FOR ALPHA/S(1) =,1PE9.2,
     1 9H) PRUNS =,0PF7.4,9X,8HPUNCOR =,5F8.4)
      WRITE (33,5110) RALPS1,PRUNS,PUNCOR
      GO TO 200
  150 CALL PLRES (YLYFIT,NY,NY,PRUNS,PUNCOR,RALPS1,NOUT,LINEPG,ITITLE,
     1 CHOSEN)
  200 IF (ILEVEL .GT. IPLFIT(ISTAGE)) GO TO 800
C-----------------------------------------------------------------------
C  TEMPORARILY PUT YFIT (FIT TO DATA) IN YLYFIT.
C  IF SQRTW(J).LE.0., THEN YFIT(J) IS ARBITRARILY SET TO Y(J).
C-----------------------------------------------------------------------
      DO 210 J=1,NY
        DUM=0.
        IF (SQRTW(J) .GT. 0.) DUM=YLYFIT(J)/SQRTW(J)
        YLYFIT(J)=Y(J)-DUM
  210 CONTINUE
 5210 FORMAT (//38H0PLOT OF DATA (O) AND FIT TO DATA (X).,
     1 34H  ORDINATES LISTED ARE FIT VALUES.)
      WRITE (33,5210)
      CALL PLPRIN (T,YLYFIT,Y,NY,.FALSE.,NOUT,SRANGE,0,0,NY,WORK,
     1 .FALSE.)
C-----------------------------------------------------------------------
C  RESTORE YLYFIT.
C-----------------------------------------------------------------------
      DO 220 J=1,NY
        YLYFIT(J)=(Y(J)-YLYFIT(J))*SQRTW(J)
  220 CONTINUE
  800 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE SEQACC.  SEQUENTIALLY ACCUMULATES N ROWS OF
C      COEFFICIENT MATRIX (1 ROW AT A TIME) AND PERFORMS
C      SEQUENTIAL HOUSEHOLDER TRANSFORMATIONS TO COMPRESS
C      PROBLEM INTO UPPER TRIANGLE OF AUGMENTED NGL-BY-(NGL+1) MATRIX A.
C  IF NY.LE.NGL, THEN ROWS ARE JUST LOADED INTO A WITHOUT ANY
C      TRIANGULARIZATION AND THE LAST (NGL-NY) ROWS ARE FILLED WITH
C      ZEROES.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - H12, GETROW
C  WHICH IN TURN CALL - USERK, ERRMES, USERLF, USERTR
C-----------------------------------------------------------------------
      SUBROUTINE SEQACC (
     1 A,CQUAD,G,IUNIT,IWT,MA,MG,NG,NGL,NGLP1,NLINF,NY,
     2 RANGE,SQRTW,SSCALE,T,Y)
      DOUBLE PRECISION A, RANGE, RHO, SSCALE, ZERO
      DIMENSION A(MA,MG), T(NY), Y(NY), SQRTW(NY), G(NG), CQUAD(NG),
     1 SSCALE(MG)
C     ZERO=0.E0!SP
      ZERO=0.D0
      L=0
      NGL=NG+NLINF
      NGLP1=NGL+1
      DO 200 IT=1,NY
        IP=L+1
        IIT=IT
        CALL GETROW (IIT,A(IP,1),.TRUE.,MA,IUNIT,
     1  SQRTW,NY,NGL,NG,CQUAD,G,T,NLINF,Y,SSCALE)
        IF (L.LE.0 .OR. NY.LE.NGL) GO TO 230
        J=MIN0(NGLP1,L)
        DO 220 I=1,J
          II=I
          CALL H12 (1,II,IP,IP,A(1,I),1,RHO,A(1,I+1),1,MA,NGLP1-I,RANGE)
  220   CONTINUE
  230   L=MIN0(NGLP1,IP)
  200 CONTINUE
      IF (NY .LE. NGL) GO TO 350
      DO 300 J=2,NGL
        L=J-1
        DO 310 K=1,L
          A(J,K)=ZERO
  310   CONTINUE
  300 CONTINUE
      GO TO 800
  350 L=NY+1
      DO 360 J=L,NGL
        DO 370 K=1,NGLP1
          A(J,K)=ZERO
  370   CONTINUE
  360 CONTINUE
  800 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE SETGA1.  PUTS D*A1 (WHICH ARE STORED IN AINEQ AND REG)
C      INTO THE FIRST NNINEQ ROWS AND NGLE COLUMNS OF A, WHERE
C      A1 = K2*Z*H1**(-1)*W IN EQ. (5.18).
      SUBROUTINE SETGA1 (NNINEQ,
     1 A,AINEQ,MA,MG,MINEQ,MREG,NGL,NGLE,REG)
      DOUBLE PRECISION A, AINEQ, DUM, REG, ZERO
      DIMENSION AINEQ(MINEQ,MG), REG(MREG,MG), A(MA,MG)
C     ZERO=0.E0!SP
      ZERO=0.D0
      DO 120 IROW=1,NNINEQ
        DO 130 ICOL=1,NGLE
          DUM=ZERO
          DO 140 J=1,NGL
            DUM=DUM+AINEQ(IROW,J)*REG(J,ICOL)
  140     CONTINUE
          A(IROW,ICOL)=DUM
  130   CONTINUE
  120 CONTINUE
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE SETGRD.  CALCULATES G (QUADRATURE GRID) AND
C      CQUAD (WEIGHTS OF QUADRATURE FORMULA).
C  IGRID=1,2, OR 3 FOR G IN EQUAL INTERVALS, FOR G IN EQUAL INTERVALS
C      OF A FUNCTION OF G (SAY H(G)), WHERE H IS DEFINED BY USER IN
C      USERTR, OR FOR G AND CQUAD TO BE COMPUTED IN USERGR, RESPECTIVELY
C  IQUAD=1,2, OR 3 FOR NO QUADRATURE (I.E., LINEAR EQUATIONS), FOR
C      TRAPEZOIDAL RULE, OR FOR SIMPSON RULE, RESPECTIVELY.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - USERGR, ERRMES, USERTR, CQTRAP
C-----------------------------------------------------------------------
      SUBROUTINE SETGRD (CQUAD,G,GMNMX,IGRID,IQUAD,MG,NG,NOUT)
      DIMENSION G(MG), CQUAD(MG), GMNMX(2)
      DIMENSION IHOLER(6)
      DATA IHOLER/1HS, 1HE, 1HT, 1HG, 1HR, 1HD/
      IF (IGRID .NE. 3) GO TO 200
C-----------------------------------------------------------------------
C  COMPUTE G AND CQUAD IN USER-SUPPLIED ROUTINE USERGR.
C-----------------------------------------------------------------------
      CALL USERGR (G,CQUAD,MG)
      GO TO 300
  200 IF (IGRID.EQ.2 .AND. AMIN1(GMNMX(1),GMNMX(2)).LE.0.) CALL
     1 ERRMES (1,.FALSE.,IHOLER,NOUT)
C-----------------------------------------------------------------------
C  COMPUTE G WHEN IGRID=1 OR 2.
C-----------------------------------------------------------------------
      G(1)=GMNMX(1)
      DELTA=(USERTR(GMNMX(2),1)-USERTR(GMNMX(1),1))/FLOAT(NG-1)
      DO 210 J=2,NG
        DUM=USERTR(G(J-1),1)+DELTA
        G(J)=USERTR(DUM,2)
  210 CONTINUE
C-----------------------------------------------------------------------
C  CHECK G FOR STRICT MONOTONICITY.
C-----------------------------------------------------------------------
  300 IF (NG .LE. 2) GO TO 350
      DELOLD=G(2)-G(1)
      DO 310 J=3,NG
        DEL=G(J)-G(J-1)
        IF (DEL*DELOLD .GT. 0.) GO TO 315
        CALL ERRMES (2,.FALSE.,IHOLER,NOUT)
 5310   FORMAT (1X,1P,10E13.3)
        WRITE (33,5310) (G(K),K=1,NG)
        STOP
  315   DELOLD=DEL
  310 CONTINUE
  350 IF (IGRID .EQ. 3) GO TO 800
C-----------------------------------------------------------------------
C  COMPUTE CQUAD.
C-----------------------------------------------------------------------
      IF (IQUAD .NE. 1) GO TO 420
C-----------------------------------------------------------------------
C  NO QUADRATURE - LINEAR ALGEBRAIC EQUATIONS ARE BEING SOLVED.
C-----------------------------------------------------------------------
      DO 410 J=1,NG
        CQUAD(J)=1.
  410 CONTINUE
      GO TO 800
  420 IF (IQUAD .NE. 2) GO TO 450
C-----------------------------------------------------------------------
C  TRAPEZOIDAL RULE.
C-----------------------------------------------------------------------
      CALL CQTRAP (G,CQUAD,NG)
      GO TO 800
  450 IF (IQUAD .NE. 3) CALL ERRMES (3,.TRUE.,IHOLER,NOUT)
C-----------------------------------------------------------------------
C  SIMPSON RULE (WITH LAST GRID PAIR DONE WITH TRAPEZOIDAL RULE IF
C      NG IS EVEN).
C-----------------------------------------------------------------------
      CQUAD(1)=DELTA/3.
      CQ2=2.*CQUAD(1)
      CQ4=CQ2+CQ2
      JJ=NG-1
      DO 460 J=2,JJ,2
        CQUAD(J)=CQ4
        CQUAD(J+1)=CQ2
  460 CONTINUE
      IF (MOD(NG,2) .EQ. 0) GO TO 470
      CQUAD(NG)=CQUAD(1)
      GO TO 500
  470 CQUAD(NG)=1.5*CQUAD(1)
      CQUAD(NG-1)=CQUAD(1)+CQUAD(NG)
  500 IF (IGRID .NE. 2) GO TO 800
C-----------------------------------------------------------------------
C  CORRECT CQUAD FOR TRANSFORMATION IN USERTR WHEN IGRID=2.
C-----------------------------------------------------------------------
      DO 510 J=1,NG
        CQUAD(J)=CQUAD(J)/USERTR(G(J),3)
  510 CONTINUE
  800 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE SETNNG.  CONSTRAINS THE SOLUTION TO BE NONNEGATIVE
C      AT ALL NG GRID POINTS.  ADDS NG NONNEGATIVITY CONSTRAINTS
C      ONTO THE LAST NG ROWS OF AINEQ.
      SUBROUTINE SETNNG (AINEQ,MINEQ,NG,NGLP1,NINEQ)
      DOUBLE PRECISION AINEQ, ONE, ZERO
      DIMENSION AINEQ(MINEQ,NGLP1)
C     ZERO=0.E0!SP
      ZERO=0.D0
C     ONE=1.E0!SP
      ONE=1.D0
      DO 210 J=1,NG
        NINEQ=NINEQ+1
        DO 220 K=1,NGLP1
          AINEQ(NINEQ,K)=ZERO
  220   CONTINUE
        AINEQ(NINEQ,J)=ONE
  210 CONTINUE
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE SETREG.  SETS UP AUGMENTED SCALED REGULARIZOR MATRIX IN
C      REG.
C  NORDER = ORDER OF REGULARIZOR, WHEN 0.LE.NORDER.LE.5.  WHEN
C      NORDER.LT.0, THEN THE REGULARIZOR IS SET IN THE
C      USER-SUPPLIED ROUTINE USERRG.
C  NENDZ SPECIFIES THE EXTERNAL BOUNDARY CONDITIONS OF THE SOLUTION
C      FOR COMPUTING THE REGULARIZOR.  NENDZ(J) = NO. OF GRID POINTS
C      BELOW G(1) FOR WHICH THE SOLUTION IS ZERO (J=1), OR THE
C      NO. OF GRID POINTS ABOVE G(NG) FOR WHICH THE SOLUTION
C      IS ZERO (J=2).  (MUST HAVE NENDZ(J).LE.NORDER FOR J=1,2, WHEN
C      NORDER.GE.0.)
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - USERRG, ERRMES
C-----------------------------------------------------------------------
      SUBROUTINE SETREG (MG,MREG,NENDZ,NG,NGL,NGLE,NGLP1,NORDER,
     1 NOUT,NREG,REG,SSCALE)
      DOUBLE PRECISION ABS, REG, SSCALE, ZERO
      DIMENSION REG(MREG,MG), NENDZ(2), SSCALE(MG)
      DIMENSION DC(6,6), IHOLER(6)
      DATA DC/1., 5*0.,   -1., 1., 4*0.,   1., -2., 1., 3*0.,
     1 -1., 3., -3., 1., 2*0.,   1., -4., 6., -4., 1., 0.,
     2 -1., 5., -10., 10., -5., 1./,
     3 IHOLER/1HS, 1HE, 1HT, 1HR, 1HE, 1HG/
      ABS(ZERO)=DABS(ZERO)
C     ZERO=0.E0!SP
      ZERO=0.D0
      IF (NORDER .GE. 0) GO TO 200
C-----------------------------------------------------------------------
C  COMPUTE REGULARIZOR IN USER-SUPPLIED ROUTINE USERRG.
C-----------------------------------------------------------------------
      CALL USERRG (REG,MREG,MG,NREG)
      IF (NREG .LE. 0) CALL ERRMES (1,.TRUE.,IHOLER,NOUT)
      GO TO 300
  200 IF (NORDER .GT. 5) CALL ERRMES (2,.TRUE.,IHOLER,NOUT)
      IF (MIN0(NENDZ(1),NENDZ(2)).LT.0 .OR.
     1 MAX0(NENDZ(1),NENDZ(2)).GT.NORDER)
     2 CALL ERRMES (3,.FALSE.,IHOLER,NOUT)
      NENDZ(1)=MAX0(0,MIN0(NENDZ(1),NORDER))
      NENDZ(2)=MAX0(0,MIN0(NENDZ(2),NORDER))
      NREG=NG+NENDZ(1)+NENDZ(2)-NORDER
      IF (MAX0(NREG,NGLE) .GE. MREG) CALL ERRMES (4,.TRUE.,IHOLER,NOUT)
      NORDP1=NORDER+1
      DO 210 J=1,NREG
        DO 220 K=1,NGLP1
          REG(J,K)=ZERO
  220   CONTINUE
        L=J-NENDZ(1)-1
        DO 230 K=1,NORDP1
          L=L+1
          IF (L.GE.1 .AND. L.LE.NG) REG(J,L)=DC(K,NORDP1)
  230   CONTINUE
  210 CONTINUE
  300 IF (SSCALE(1) .LE. ZERO) GO TO 800
C-----------------------------------------------------------------------
C  SCALE REGULARIZOR WITH SSCALE AND DIVIDE ALL THE ELEMENTS OF THE
C      REGULARIZOR AND ITS RIGHT-HAND SIDE BY THE AVERAGE ABSOLUTE
C      ELEMENT SIZE.
C-----------------------------------------------------------------------
      AVGREG=ZERO
      DO 310 ICOL=1,NGL
        DO 320 IROW=1,NREG
          REG(IROW,ICOL)=REG(IROW,ICOL)*SSCALE(ICOL)
          AVGREG=AVGREG+ABS(REG(IROW,ICOL))
  320   CONTINUE
  310 CONTINUE
      IF (AVGREG .LE. ZERO) CALL ERRMES (5,.TRUE.,IHOLER,NOUT)
      AVGREG=FLOAT(NGL*NREG)/AVGREG
      DO 330 ICOL=1,NGLP1
        DO 340 IROW=1,NREG
          REG(IROW,ICOL)=REG(IROW,ICOL)*AVGREG
  340   CONTINUE
  330 CONTINUE
      DUM=AVGREG
 5340 FORMAT (25H0SCALE FACTOR FOR ALPHA =,1PE11.3)
      WRITE (33,5340) DUM
      IF (NREG .GE. NGLE) GO TO 800
C-----------------------------------------------------------------------
C  AUGMENT REGULARIZOR WITH ZERO ROWS TO MAKE NREG=NGLE.
C-----------------------------------------------------------------------
      L=NREG+1
      DO 350 ICOL=1,NGLP1
        DO 360 IROW=L,NGLE
          REG(IROW,ICOL)=ZERO
  360   CONTINUE
  350 CONTINUE
      NREG=NGLE
  800 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE SETSCA.  PUTS SCALE FACTORS FOR SOLUTION IN SSCALE AND
C      SCALES INEQUALITY MATRIX AINEQ.  L1 LENGTHS ARE USED
C      THROUGHOUT TO AVOID UNDERFLOWS AND OVERFLOWS DUE TO SQUARING.
C  OUTPUTS SCALE FACTORS AND MIN AND MAX ELEMENTS OF EACH COLUMN OF
C      THE COEFFICIENT MATRIX A.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - ERRMES, SETREG, GETROW
C  WHICH IN TURN CALL - USERRG, USERK, USERLF, USERTR
C-----------------------------------------------------------------------
      SUBROUTINE SETSCA (AAMAX,AAMIN,TMAX,TMIN,
     1 AINEQ,CQUAD,G,ISTAGE,MG,MINEQ,MREG,MY,NGLE,REG,S,SQRTW,SSCALE,T,
     2 Y)
      DOUBLE PRECISION ABS, AINEQ, REG, S, SSCALE, ONE, ZERO, DUB,
     1 AAMAX,AAMIN,TMAX,TMIN
      DOUBLE PRECISION PRECIS, RANGE
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      DIMENSION AINEQ(MINEQ,MG), CQUAD(MG), G(MG), REG(MREG,MG),
     1 S(MG,3), SQRTW(MY), SSCALE(MG), T(MY), Y(MY),
     2 AAMAX(1), AAMIN(1), TMAX(1), TMIN(1)
      DIMENSION IHOLER(6)
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
      DATA IHOLER/1HS, 1HE, 1HT, 1HS, 1HC, 1HA/
      ABS(DUB)=DABS(DUB)
C     ZERO=0.E0!SP
      ZERO=0.D0
C     ONE=1.E0!SP
      ONE=1.D0
      IF (ISTAGE.EQ.1 .OR. IWT.EQ.1 .OR. IWT.EQ.4 .OR. NINEQ.LE.0) GO
     1 TO 150
C-----------------------------------------------------------------------
C  UNSCALE INEQUALITY CONSTRAINTS.
C-----------------------------------------------------------------------
      DO 110 ICOL=1,NGL
        IF (SSCALE(ICOL) .LE. ZERO) CALL ERRMES (1,.TRUE.,IHOLER,NOUT)
        DUB=ONE/SSCALE(ICOL)
        DO 120 IROW=1,NINEQ
          AINEQ(IROW,ICOL)=AINEQ(IROW,ICOL)*DUB
  120   CONTINUE
  110 CONTINUE
C-----------------------------------------------------------------------
C  INITIALIZE SCALE FACTOR, S(J,1), ETC.
C-----------------------------------------------------------------------
  150 SSCALE(1)=ZERO
      DO 160 J=1,NGL
        S(J,1)=ZERO
        AAMAX(J)=-RANGE
        AAMIN(J)=RANGE
  160 CONTINUE
C-----------------------------------------------------------------------
C  PUT MAGNITUDES OF COLUMN VECTORS OF REGULARIZOR IN S(J,2),
C      J=1,NGL.
C-----------------------------------------------------------------------
      CALL SETREG (MG,MREG,NENDZ,NG,NGL,NGLE,NGLP1,NORDER,NOUT,NREG,
     1 REG,SSCALE)
      DO 210 ICOL=1,NGL
        DUB=ZERO
        DO 220 IROW=1,NREG
          DUB=DUB+ABS(REG(IROW,ICOL))
  220   CONTINUE
        S(ICOL,2)=DUB
        SSCALE(ICOL)=ONE
  210 CONTINUE
C-----------------------------------------------------------------------
C  PUT MAGNITUDES OF COLUMN VECTORS OF COEFFICIENT MATRIX IN
C      S(J,1), J=1,NGL.
C-----------------------------------------------------------------------
      DO 230 IROW=1,NY
        J=IROW
        CALL GETROW (J,S(1,3),.TRUE.,1,IUNIT,
     1  SQRTW,NY,NGL,NG,CQUAD,G,T,NLINF,Y,SSCALE)
        DO 240 ICOL=1,NGL
          S(ICOL,1)=S(ICOL,1)+ABS(S(ICOL,3))
          IF (S(ICOL,3) .GE. AAMIN(ICOL)) GO TO 245
          AAMIN(ICOL)=S(ICOL,3)
          TMIN(ICOL)=T(IROW)
  245     IF (S(ICOL,3) .LE. AAMAX(ICOL)) GO TO 240
          AAMAX(ICOL)=S(ICOL,3)
          TMAX(ICOL)=T(IROW)
  240   CONTINUE
  230 CONTINUE
C-----------------------------------------------------------------------
C  S(J,2)=0 MEANS THAT COLUMN J OF THE REGULARIZOR IS ZERO AND
C      THEREFORE THAT THE J-TH VARIABLE IS NOT REGULARIZED.
C  SSCALE(J) OF REGULARIZED VARIABLES ARE INITIALLY SET TO NORMALIZE
C      THEIR COLUMN VECTORS IN THE REGULARIZOR.
C  NACTRG = NO. OF REGULARIZED VARIABLES.
C  AVCOER = AVERAGE (OVER REGULARIZED VARIABLES) OF THE LENGTHS OF THE
C      COLUMN VECTORS IN THE SCALED COEFFICIENT MATRIX.
C-----------------------------------------------------------------------
      NACTRG=0
      AVCOER=0.
      DO 260 J=1,NGL
        IF (S(J,2) .LE. ZERO) GO TO 260
        NACTRG=NACTRG+1
        SSCALE(J)=ONE/S(J,2)
        AVCOER=AVCOER+S(J,1)*SSCALE(J)
  260 CONTINUE
      IF (NACTRG .LE. 0) CALL ERRMES (2,.TRUE.,IHOLER,NOUT)
      AVCOER=AVCOER/FLOAT(NACTRG)
C-----------------------------------------------------------------------
C  SSCALE(J) FOR THE REGULARIZED VARIABLES ARE FINALLY ALL DIVIDED BY
C      AVCOER.  THIS MAKES THE AVERAGE LENGTH OF THEIR COLUMN VECTORS
C      IN THE SCALED COEFFICIENT MATRIX 1.
C  SSCALE(J) FOR THE NON-REGULARIZED VARIABLES IS SET TO NORMALIZE
C      THEIR COLUMN VECTORS IN THE SCALED COEFFICIENT MATRIX.
C-----------------------------------------------------------------------
      DO 280 J=1,NGL
        IF (S(J,2) .LE. ZERO) GO TO 285
        SSCALE(J)=SSCALE(J)/AVCOER
        GO TO 280
  285   IF (S(J,1) .LE. ZERO) CALL ERRMES (3,.TRUE.,IHOLER,NOUT)
        SSCALE(J)=ONE/S(J,1)
  280 CONTINUE
C-----------------------------------------------------------------------
C  SCALE INEQUALITY CONSTRAINTS AND NORMALIZE THEIR ROW VECTORS.
C-----------------------------------------------------------------------
      IF (NINEQ .LE. 0) GO TO 400
      DO 310 ICOL=1,NGL
        DUB=SSCALE(ICOL)
        DO 320 IROW=1,NINEQ
          AINEQ(IROW,ICOL)=AINEQ(IROW,ICOL)*DUB
  320   CONTINUE
  310 CONTINUE
      DO 340 IROW=1,NINEQ
        DUB=ZERO
        DO 350 ICOL=1,NGL
          DUB=DUB+ABS(AINEQ(IROW,ICOL))
  350   CONTINUE
        IF (DUB .LE. ZERO) CALL ERRMES (4,.TRUE.,IHOLER,NOUT)
        DUB=ONE/DUB
        DO 360 ICOL=1,NGLP1
          AINEQ(IROW,ICOL)=AINEQ(IROW,ICOL)*DUB
  360   CONTINUE
  340 CONTINUE
 5400 FORMAT (//3X,10HGRID POINT,5X,15HMIN IN MATRIX A,4X,6HAT T =,5X,
     1 15HMAX IN MATRIX A,4X,6HAT T =,5X,12HSCALE FACTOR)
  400 WRITE (33,5400)
C5410 FORMAT (1X,1PE12.4,E20.4,E10.2,E20.4,E10.2,E17.3)!SP
 5410 FORMAT (1X,1PE12.4,D20.4,D10.2,D20.4,D10.2,D17.3)
      WRITE (33,5410) (G(J),AAMIN(J),TMIN(J),AAMAX(J),TMAX(J),
     1 SSCALE(J),J=1,NG)
      IF (NG .GE. NGL) GO TO 800
C5420 FORMAT (13H  NLINF TERMS,1PE20.4,E10.2,E20.4,E10.2,E17.3)!SP
 5420 FORMAT (13H  NLINF TERMS,1PD20.4,D10.2,D20.4,D10.2,D17.3)
      K=NG+1
      WRITE (33,5420) (AAMIN(J),TMIN(J),AAMAX(J),TMAX(J),
     1 SSCALE(J),J=K,NGL)
  800 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE SETSGN.  SETS UP LLSIGN(J) (+ OR - THE SUBSCRIPT OF THE
C      J-TH EXTREMA, WITH + IF A MAX. AND - IF A MIN.)
C      FROM THE INPUT VALUES OF LSIGN(J,INSGN),
C      FOR J=1,...,NSGN(INSGN)+1=NSGNI+1.
C  FOR THE SPECIAL CASE OF A SINGLE PEAK AND LSIGN(2,INSGN) INPUT AS 0,
C      THE MIN. OF LSIGN(1,INSGN)*SOLBES (WHERE SOLBES IS THE BEST
C      SOLUTION FOUND SO FAR) IS USED.
C  LLSIGN(1) = + OR -1.  LLSIGN(NSGN(INSGN)+1)=NG.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - ERRMES
C-----------------------------------------------------------------------
      SUBROUTINE SETSGN (INSGN,NSGNI,LSIGN,NOUT,LLSIGN,NG,SOLBES,
     1 SRANGE)
      DOUBLE PRECISION SOLBES
      DIMENSION LSIGN(4,INSGN), LLSIGN(5), SOLBES(NG)
      DIMENSION IHOLER(6)
      DATA IHOLER/1HS, 1HE, 1HT, 1HS, 1HG, 1HN/
      IF (NSGNI.LT.1 .OR. NSGNI.GT.4 .OR. IABS(LSIGN(1,INSGN)).NE.1)
     1 CALL ERRMES (1,.TRUE.,IHOLER,NOUT)
      LLSIGN(1)=LSIGN(1,INSGN)
      LLSIGN(NSGNI+1)=NG
      IF (NSGNI .EQ. 1) GO TO 800
      DO 110 ISGN=2,NSGNI
        LLSIGN(ISGN)=LSIGN(ISGN,INSGN)
        IF (IABS(LLSIGN(ISGN)) .GT. IABS(LLSIGN(ISGN-1)) .AND.
     1  IABS(LLSIGN(ISGN)) .LT. NG   .AND.
     2  LLSIGN(ISGN)*LLSIGN(ISGN-1) .LT. 0) GO TO 110
        IF (ISGN.NE.2 .OR. NSGNI.NE.2) CALL ERRMES(2,.TRUE.,IHOLER,NOUT)
C-----------------------------------------------------------------------
C  SELECT STARTING SINGLE PEAK FROM THE ABSOLUTE MIN. OF
C      LLSIGN(1)*SOLBES.
C-----------------------------------------------------------------------
        F=FLOAT(LLSIGN(1))
        PK=SRANGE
        DO 120 J=1,NG
          DUM=F*SOLBES(J)
          IF (DUM .GE. PK) GO TO 120
          PK=DUM
          LLSIGN(2)=-ISIGN(J,LLSIGN(1))
  120   CONTINUE
  110 CONTINUE
  800 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE SETVAL.  PUTS S(TILDE)(J,J) (IN EQ. (5.22)) IN S(J,2).
C  EVALUAUES VALPHA(J) AND VALPCV(J), J=1,NGL, WHERE
C      VALPCV = K1*X1+K2*Z*H1**(-1)*R1 AND
C      VALPHA = K1*X1+K2*Z*H1**(-1)*(W*S(TILDE)**(-1)*GAMMA(TILDE)+R1)
C      IN EQ. (5.29).
C  UPDATES A AND RHSNEQ (LEFT- AND RIGHT-HAND SIDES OF EQ. (5.28)).
C  INIT SHOULD ONLY BE .TRUE. ON THE FIRST CALL TO SETVAL AFTER A
C      CALL TO SETGA1.
      SUBROUTINE SETVAL (ALPHA,INIT,NNINEQ,
     1  A,AINEQ,MA,MG,MINEQ,MREG,NGL,NGLE,REG,RHSNEQ,S,VALPCV,VALPHA,
     2  VK1Y1)
      DOUBLE PRECISION A, AINEQ, ALPHA, ALPHA2, DDUM, DUM, FACT,
     1 ONE, REG, RHSNEQ, S, SQRT, VALPCV, VALPHA, VK1Y1
      LOGICAL INIT
      DIMENSION S(MG,3), VK1Y1(MG), REG(MREG,MG), A(MA,MG),
     1 VALPHA(MG), VALPCV(MG), AINEQ(MINEQ,MG), RHSNEQ(MINEQ)
      SQRT(DUM)=DSQRT(DUM)
C     ONE=1.E0!SP
      ONE=1.D0
      IF (.NOT.INIT) GO TO 108
      DO 105 J=1,NGLE
        S(J,2)=ONE
  105 CONTINUE
  108 ALPHA2=ALPHA**2
      DO 110 J=1,NGL
        VALPCV(J)=VK1Y1(J)
        VALPHA(J)=VK1Y1(J)
  110 CONTINUE
      NGLP1=NGL+1
      DO 120 J=1,NGLE
        DDUM=ONE/(S(J,1)**2+ALPHA2)
        DUM=(ALPHA2*REG(J,NGLP1)+S(J,1)*A(J,NGLP1))*DDUM
        DDUM=SQRT(DDUM)
        FACT=DDUM/S(J,2)
        S(J,2)=DDUM
        DO 125 K=1,NGL
          VALPHA(K)=VALPHA(K)+DUM*REG(K,J)
  125   CONTINUE
        IF (NNINEQ .LE. 0) GO TO 120
C-----------------------------------------------------------------------
C  COMPUTE VALPCV FOR LATER USE IN CVNEQ.
C-----------------------------------------------------------------------
        DUM=REG(J,NGLP1)
        DO 130 K=1,NGL
          VALPCV(K)=VALPCV(K)+DUM*REG(K,J)
  130   CONTINUE
C-----------------------------------------------------------------------
C  UPDATE NNINEQ-BY-NGLE INEQUALITY MATRIX A.
C-----------------------------------------------------------------------
        DO 140 K=1,NNINEQ
          A(K,J)=FACT*A(K,J)
  140   CONTINUE
  120 CONTINUE
      IF (NNINEQ .LE. 0) GO TO 800
C-----------------------------------------------------------------------
C  PUT RIGHT-HAND-SIDE OF INEQUALITY IN RHSNEQ.
C-----------------------------------------------------------------------
      DO 150 K=1,NNINEQ
        DUM=AINEQ(K,NGLP1)
        DO 160 J=1,NGL
          DUM=DUM-AINEQ(K,J)*VALPHA(J)
  160   CONTINUE
        RHSNEQ(K)=DUM
  150 CONTINUE
  800 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE SETWT.  COMPUTES SQRTW (SQUARE-ROOTS OF THE LEAST
C      SQUARES WEIGHTS) USING ABS(Y-YLYFIT)=YFIT (THE ABSOLUTE VALUE
C      OF THE FIT TO THE DATA FROM A PRELIMINARY UNWEIGHTED SOLUTION).
C  ONLY CALLED IF IWT=2,3, OR 5.
C  IWT = 2 WHEN VARIANCE (Y) IS PROPORTIONAL TO ABS(Y) (AS WITH POISSON
C      STATISTICS).
C  IWT = 3 WHEN VARIANCE (Y) IS PROPORTIONAL TO Y**2.
C  IWT = 5 WHEN SQRTW IS TO BE CALCULATED BY THE USER-SUPPLIED
C      ROUTINE USERWT.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - GETYLY, USERWT, ERRMES
C  WHICH IN TURN CALL - GETROW, USERK, USERLF, USERTR
C-----------------------------------------------------------------------
      SUBROUTINE SETWT (
     1 CQUAD,G,IUNIT,IWT,MWORK,MY,NERFIT,NG,NGL,NLINF,NOUT,NY,PRWT,
     2 SOLBES,SQRTW,SRANGE,SSCALE,T,WORK,Y,YLYFIT)
      DOUBLE PRECISION SOLBES, SSCALE, WORK
      LOGICAL PRWT
      DIMENSION SOLBES(NGL), WORK(MWORK), SQRTW(MY), CQUAD(NG),
     1 G(NG), T(MY), Y(MY), YLYFIT(MY), SSCALE(NGL)
      DIMENSION IHOLER(6)
      DATA IHOLER/1HS, 1HE, 1HT, 1HW, 1HT, 1H /
      CALL GETYLY (SOLBES,
     1 CQUAD,G,IUNIT,IWT,MWORK,NG,NGL,NLINF,NY,SQRTW,SSCALE,T,WORK,Y,
     2 YLYFIT)
      ERRFIT=0.
      IF (NERFIT.LE.0) GO TO 200
C-----------------------------------------------------------------------
C  COMPUTE ERRFIT (ROOT-MEAN-SQUARE DEVIATION IN THE REGION
C      AROUND THE MIN. VALUE OF YFIT).  ERRFIT WILL BE
C      ADDED TO YFIT IN ORDER TO PREVENT DISASTROUSLY LARGE WEIGHTS
C      BEING CALCULATED FROM 1./YFIT, WHEN YFIT HAPPENS TO BE NEAR 0.
C  NERFIT SHOULD TYPICALLY BE ABOUT 10.
C-----------------------------------------------------------------------
      ABSMIN=SRANGE
      DO 110 J=1,NY
        DUM=ABS(Y(J)-YLYFIT(J))
        IF (DUM .GE. ABSMIN) GO TO 110
        ABSMIN=DUM
        L=J
  110 CONTINUE
      JMAX=MIN0(NY,L+NERFIT/2)
      JMIN=MAX0(1,JMAX-NERFIT+1)
      DUM=0.
      DO 120 J=JMIN,JMAX
        DUM=DUM+YLYFIT(J)**2
  120 CONTINUE
      ERRFIT=SQRT(DUM/FLOAT(JMAX-JMIN+1))
  200 IF (IWT .NE. 5) GO TO 250
      CALL USERWT (Y,YLYFIT,MY,ERRFIT,SQRTW)
      GO TO 700
  250 IF (IWT.NE.2 .AND. IWT.NE.3) CALL ERRMES (1,.TRUE.,IHOLER,NOUT)
      DO 260 J=1,NY
        DUM=AMAX1(ABS(Y(J)-YLYFIT(J)),ERRFIT)
        IF (DUM .LE. 0.) CALL ERRMES (2,.TRUE.,IHOLER,NOUT)
        SQRTW(J)=1./DUM
        IF (IWT .EQ. 2) SQRTW(J)=SQRT(SQRTW(J))
  260 CONTINUE
 5260 FORMAT (//9H ERRFIT =,1PE9.2/30X,
     A 37HSQUARE ROOTS OF LEAST SQUARES WEIGHTS/
     1 (1X,1P,10E13.4))
  700 IF (PRWT) WRITE (33,5260) ERRFIT,(SQRTW(J),J=1,NY)
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBPROGRAM STORIN. STORES INPUT DATA AFTER CHECKING THAT
C      ARRAY DIMENSIONS WILL NOT BE EXCEEDED.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - ERRMES
C-----------------------------------------------------------------------
      SUBROUTINE STORIN (JL,NIOERR,LIN,IIN,RIN)
      DOUBLE PRECISION PRECIS, RANGE
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      LOGICAL LEQUIV(11)
      DIMENSION LIN(6), IEQUIV(14), REQUIV(2), IHOLER(6)
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
      EQUIVALENCE (IGRID,IEQUIV(1)), (DOCHOS,LEQUIV(1)),
     1 (DFMIN,REQUIV(1))
      DATA IHOLER/1HS, 1HT, 1HO, 1HR, 1HI, 1HN/
      IFINT(RIN)=INT(RIN+SIGN(.5,RIN))
      IF (JL .GT. 2) GO TO 200
      REQUIV(JL)=RIN
      RETURN
  200 IF (JL .GT. 7) GO TO 300
      JLL=JL-2
      GO TO (203,204,205,206,207),JLL
  203 IF (IIN.LT.1 .OR. IIN.GT.2) GO TO 805
      ALPST(IIN)=RIN
      RETURN
  204 IF (IIN.LT.1 .OR. IIN.GT.2) GO TO 805
      GMNMX(IIN)=RIN
      RETURN
 5205 FORMAT (4F5.2)
  205 READ (NIN,5205) PLEVEL
      WRITE (33,5205) PLEVEL
      RETURN
 5206 FORMAT (4E10.3)
  206 READ (NIN,5206) RSVMNX
      WRITE (33,5206) RSVMNX
      RETURN
C***********************************************************************
C  IF YOU CHANGE THE DIMENSION OF RUSER IN COMMON, THEN YOU MUST ALSO
C      CHANGE 100 IN THE FOLLOWING STATEMENT TO THE NEW DIMENSION.
C***********************************************************************
  207 IF (IIN.LT.1 .OR. IIN.GT.100) GO TO 805
      RUSER(IIN)=RIN
      RETURN
  300 IF (JL .GT. 21) GO TO 400
      IEQUIV(JL-7)=IFINT(RIN)
      RETURN
  400 IF (JL .GT. 37) GO TO 500
      JLL=JL-21
      GO TO (422,423,424,425,426,427,428,429,430,431,432,433,434,435,
     1 436,437),JLL
  422 IF (IIN.LT.1 .OR. IIN.GT.2) GO TO 805
      ICRIT(IIN)=IFINT(RIN)
      RETURN
 5423 FORMAT (1X,70A1)
  423 READ (NIN,5423) IFORMT
      WRITE (33,5423) IFORMT
      RETURN
  424 READ (NIN,5423) IFORMW
      WRITE (33,5423) IFORMW
      RETURN
  425 READ (NIN,5423) IFORMY
      WRITE (33,5423) IFORMY
      RETURN
  426 IF (IIN.LT.1 .OR. IIN.GT.2) GO TO 805
      IPLFIT(IIN)=IFINT(RIN)
      RETURN
  427 IF (IIN.LT.1 .OR. IIN.GT.2) GO TO 805
      IPLRES(IIN)=IFINT(RIN)
      RETURN
  428 IF (IIN.LT.1 .OR. IIN.GT.2) GO TO 805
      IPRINT(IIN)=IFINT(RIN)
      RETURN
C***********************************************************************
C  IF YOU CHANGE THE DIMENSION OF IUSER IN COMMON, THEN YOU MUST ALSO
C      CHANGE 50 IN THE FOLLOWING STATEMENT TO THE NEW DIMENSION.
C***********************************************************************
  429 IF (IIN.LT.1 .OR. IIN.GT.50) GO TO 805
      IUSER(IIN)=IFINT(RIN)
      RETURN
  430 IF (IIN.LT.1 .OR. IIN.GT.2) GO TO 805
      IUSROU(IIN)=IFINT(RIN)
      RETURN
 5431 FORMAT (16I5)
  431 READ (NIN,5431) LSIGN
      WRITE (33,5431) LSIGN
      RETURN
  432 IF (IIN.LT.1 .OR. IIN.GT.2) GO TO 805
      MOMNMX(IIN)=IFINT(RIN)
      RETURN
  433 IF (IIN.LT.1 .OR. IIN.GT.2) GO TO 805
      NENDZ(IIN)=IFINT(RIN)
      RETURN
  434 READ (NIN,5431) NFLAT
      WRITE (33,5431) NFLAT
      RETURN
  435 IF (IIN.LT.1 .OR. IIN.GT.2) GO TO 805
      NNSGN(IIN)=IFINT(RIN)
      RETURN
  436 IF (IIN.LT.1 .OR. IIN.GT.2) GO TO 805
      NQPROG(IIN)=IFINT(RIN)
      RETURN
  437 IF (IIN.LT.1 .OR. IIN.GT.4) GO TO 805
      NSGN(IIN)=IFINT(RIN)
      RETURN
  500 L=IFINT(RIN)
      IF (IABS(L) .EQ. 1) GO TO 510
      CALL ERRMES (1,.FALSE.,IHOLER,NOUT)
      GO TO 810
  510 IF (JL .GT. 48) GO TO 600
      LEQUIV(JL-37)=L .EQ. 1
      RETURN
C***********************************************************************
C  IF YOU CHANGE THE DIMENSION OF LUSER IN COMMON, THEN YOU MUST ALSO
C      CHANGE 30 IN THE FOLLOWING STATEMENT TO THE NEW DIMENSION.
C***********************************************************************
  600 IF (IIN.LT.1 .OR. IIN.GT.30) GO TO 805
      LUSER(IIN)=L .EQ. 1
      RETURN
  805 CALL ERRMES (2,.FALSE.,IHOLER,NOUT)
  810 NIOERR=NIOERR+1
      IF (NIOERR .GE. MIOERR) STOP
 5002 FORMAT (/1H )
      WRITE (33,5002)
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C     SUBROUTINE SVDRS2 (A,MDA,MM,NN,B,MDB,NB,S,IERROR,RANGE)
C  BASED ON LAWSON-HANSON SVDRS EXCEPT THAT STOP IS REPLACED WITH
C      IERROR=5 AND RETURN, AND IERROR=6 IF MIN0(MM,NN).LE.0.
C  ON A NORMAL RETURN, IERROR=1.
C  RANGE IS 2 OR 3 ORDERS OF MAGNITUDE SMALLER THAN BIG, WHERE BIG IS
C      THE LARGEST NUMBER THAT DOES NOT OVERFLOW AND 1/BIG DOES NOT
C      UNDERFLOW.  FOR THE DOUBLE PRECISION VERSION, BIG AND RANGE
C      ARE IN DOUBLE PRECISION.  FOR THE SINGLE PRECISION VERSION,
C      THEY ARE IN SINGLE PRECISION (AND THEREFORE RANGE=SRANGE).
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - H12, QRBD
C  WHICH IN TURN CALL - G1, G2, DIFF
C-----------------------------------------------------------------------
C         SINGULAR VALUE DECOMPOSITION ALSO TREATING RIGHT SIDE VECTOR.
C
C     THE ARRAY S OCCUPIES 3*N CELLS.
C     A OCCUPIES M*N CELLS
C     B OCCUPIES M*NB CELLS.
C
C     SPECIAL SINGULAR VALUE DECOMPOSITION SUBROUTINE.
C     WE HAVE THE M X N MATRIX A AND THE SYSTEM A*X=B TO SOLVE.
C     EITHER M .GE. N  OR  M .LT. N IS PERMITTED.
C                  THE SINGULAR VALUE DECOMPOSITION
C     A = U*S*V**(T) IS MADE IN SUCH A WAY THAT ONE GETS
C       (1) THE MATRIX V IN THE FIRST N ROWS AND COLUMNS OF A.
C       (2) THE DIAGONAL MATRIX OF ORDERED SINGULAR VALUES IN
C       THE FIRST N CELLS OF THE ARRAY S(IP), IP .GE. 3*N.
C       (3) THE MATRIX PRODUCT U**(T)*B=G GETS PLACED BACK IN B.
C       (4) THE USER MUST COMPLETE THE SOLUTION AND DO HIS OWN
C       SINGULAR VALUE ANALYSIS.
C     *******
C     GIVE SPECIAL
C     TREATMENT TO ROWS AND COLUMNS WHICH ARE ENTIRELY ZERO.  THIS
C     CAUSES CERTAIN ZERO SING. VALS. TO APPEAR AS EXACT ZEROS RATHER
C     THAN AS ABOUT ETA TIMES THE LARGEST SING. VAL.   IT SIMILARLY
C     CLEANS UP THE ASSOCIATED COLUMNS OF U AND V.
C     METHOD..
C     1. EXCHANGE COLS OF A TO PACK NONZERO COLS TO THE LEFT.
C        SET N = NO. OF NONZERO COLS.
C        USE LOCATIONS A(1,NN),A(1,NN-1),...,A(1,N+1) TO RECORD THE
C        COL PERMUTATIONS.
C     2. EXCHANGE ROWS OF A TO PACK NONZERO ROWS TO THE TOP.
C        QUIT PACKING IF FIND N NONZERO ROWS.  MAKE SAME ROW EXCHANGES
C        IN B.  SET M SO THAT ALL NONZERO ROWS OF THE PERMUTED A
C        ARE IN FIRST M ROWS.  IF M .LE. N THEN ALL M ROWS ARE
C        NONZERO.  IF M .GT. N THEN THE FIRST N ROWS ARE KNOWN
C        TO BE NONZERO,AND ROWS N+1 THRU M MAY BE ZERO OR NONZERO.
C     3. APPLY ORIGINAL ALGORITHM TO THE M BY N PROBLEM.
C     4. MOVE PERMUTATION RECORD FROM A(,) TO S(I),I=N+1,...,NN.
C     5. BUILD V UP FROM  N BY N  TO NN BY NN BY PLACING ONES ON
C        THE DIAGONAL AND ZEROS ELSEWHERE.  THIS IS ONLY PARTLY DONE
C        EXPLICITLY.  IT IS COMPLETED DURING STEP 6.
C     6. EXCHANGE ROWS OF V TO COMPENSATE FOR COL EXCHANGES OF STEP 2.
C     7. PLACE ZEROS IN  S(I),I=N+1,NN  TO REPRESENT ZERO SING VALS.
C
      SUBROUTINE SVDRS2 (A,MDA,MM,NN,B,MDB,NB,S,IERROR,RANGE)
      DOUBLE PRECISION A, B, ONE, RANGE, S, T, ZERO
      DIMENSION A(MDA,1),B(MDB,1),S(NN,3)
C     ZERO=0.E0!SP
      ZERO=0.D0
C     ONE=1.E0!SP
      ONE=1.D0
C
C          BEGIN.. SPECIAL FOR ZERO ROWS AND COLS.
C
C          PACK THE NONZERO COLS TO THE LEFT
C
      N=NN
      IERROR=6
      IF (N.LE.0.OR.MM.LE.0) RETURN
      IERROR=1
      J=N
   10 CONTINUE
         DO 20 I=1,MM
         IF (A(I,J)) 50,20,50
   20    CONTINUE
C
C        COL J  IS ZERO. EXCHANGE IT WITH COL N.
C
      IF (J.EQ.N) GO TO 40
         DO 30 I=1,MM
   30    A(I,J)=A(I,N)
   40 CONTINUE
      A(1,N)=J
      N=N-1
   50 CONTINUE
      J=J-1
      IF (J.GE.1) GO TO 10
C          IF N=0 THEN A IS ENTIRELY ZERO AND SVD
C          COMPUTATION CAN BE SKIPPED
      NS=0
      IF (N.EQ.0) GO TO 240
C          PACK NONZERO ROWS TO THE TOP
C          QUIT PACKING IF FIND N NONZERO ROWS
      I=1
      M=MM
   60 IF (I.GT.N.OR.I.GE.M) GO TO 150
      IF (A(I,I)) 90,70,90
   70    DO 80 J=1,N
         IF (A(I,J)) 90,80,90
   80    CONTINUE
      GO TO 100
   90 I=I+1
      GO TO 60
C          ROW I IS ZERO
C          EXCHANGE ROWS I AND M
  100 IF(NB.LE.0) GO TO 115
         DO 110 J=1,NB
         T=B(I,J)
         B(I,J)=B(M,J)
  110    B(M,J)=T
  115    DO 120 J=1,N
  120    A(I,J)=A(M,J)
      IF (M.GT.N) GO TO 140
         DO 130 J=1,N
  130    A(M,J)=ZERO
  140 CONTINUE
C          EXCHANGE IS FINISHED
      M=M-1
      GO TO 60
C
  150 CONTINUE
C          END.. SPECIAL FOR ZERO ROWS AND COLUMNS
C          BEGIN.. SVD ALGORITHM
C     METHOD..
C     (1)  REDUCE THE MATRIX TO UPPER BIDIAGONAL FORM WITH
C     HOUSEHOLDER TRANSFORMATIONS.
C         H(N)...H(1)AQ(1)...Q(N-2) = (D**T,0)**T
C     WHERE D IS UPPER BIDIAGONAL.
C
C     (2)  APPLY H(N)...H(1) TO B. HERE H(N)...H(1)*B REPLACES B
C     IN STORAGE.
C
C     (3)  THE MATRIX PRODUCT W= Q(1)...Q(N-2) OVERWRITES THE FIRST
C     N ROWS OF A IN STORAGE.
C
C     (4)  AN SVD FOR D IS COMPUTED.  HERE K ROTATIONS RI AND PI ARE
C     COMPUTED SO THAT
C         RK...R1*D*P1**(T)...PK**(T) = DIAG(S1,...,SM)
C     TO WORKING ACCURACY.  THE SI ARE NONNEGATIVE AND NONINCREASING.
C     HERE RK...R1*B OVERWRITES B IN STORAGE WHILE
C     A*P1**(T)...PK**(T)  OVERWRITES A IN STORAGE.
C
C     (5)  IT FOLLOWS THAT,WITH THE PROPER DEFINITIONS,
C     U**(T)*B OVERWRITES B, WHILE V OVERWRITES THE FIRST N ROW AND
C     COLUMNS OF A.
C
      L=MIN0(M,N)
C        THE FOLLOWING LOOP REDUCES A TO UPPER BIDIAGONAL AND
C        ALSO APPLIES THE PREMULTIPLYING TRANSFORMATIONS TO B.
C
         DO 170 J=1,L
         IF (J.GE.M) GO TO 160
         JJ=J
         CALL H12 (1,JJ,J+1,M,A(1,J),1,T,A(1,J+1),1,MDA,N-J,RANGE)
         CALL H12 (2,JJ,J+1,M,A(1,J),1,T,B,1,MDB,NB,RANGE)
  160    IF (J.GE.N-1) GO TO 170
         CALL H12 (1,J+1,J+2,N,A(J,1),MDA,S(J,3),A(J+1,1),MDA,1,M-J,
     1   RANGE)
  170    CONTINUE
C
C     COPY THE BIDIAGONAL MATRIX INTO THE ARRAY S() FOR QRBD.
C
      IF (N.EQ.1) GO TO 190
         DO 180 J=2,N
         S(J,1)=A(J,J)
  180    S(J,2)=A(J-1,J)
  190 S(1,1)=A(1,1)
C
      NS=N
      IF (M.GE.N) GO TO 200
      NS=M+1
      S(NS,1)=ZERO
      S(NS,2)=A(M,M+1)
  200 CONTINUE
C
C     CONSTRUCT THE EXPLICIT N BY N PRODUCT MATRIX, W=Q1*Q2*...*QL*I
C     IN THE ARRAY A().
C
         DO 230 K=1,N
         I=N+1-K
         IF(I.GT.MIN0(M,N-2)) GO TO 210
         CALL H12 (2,I+1,I+2,N,A(I,1),MDA,S(I,3),A(1,I+1),1,MDA,N-I,
     1   RANGE)
  210    DO 220 J=1,N
  220    A(I,J)=ZERO
  230    A(I,I)=ONE
C
C         COMPUTE THE SVD OF THE BIDIAGONAL MATRIX
C
      CALL QRBD (IPASS,S(1,1),S(1,2),NS,A,MDA,N,B,MDB,NB,RANGE)
C
      GO TO (240,310), IPASS
  240 CONTINUE
      IF (NS.GE.N) GO TO 260
      NSP1=NS+1
         DO 250 J=NSP1,N
  250    S(J,1)=ZERO
  260 CONTINUE
      IF (N.EQ.NN) RETURN
      NP1=N+1
C               MOVE RECORD OF PERMUTATIONS
C               AND STORE ZEROS
         DO 280 J=NP1,NN
         S(J,1)=A(1,J)
         DO 270 I=1,N
  270    A(I,J)=ZERO
  280    CONTINUE
C          PERMUTE ROWS AND SET ZERO SINGULAR VALUES.
         DO 300 K=NP1,NN
         I=S(K,1)
         S(K,1)=ZERO
         DO 290 J=1,NN
         A(K,J)=A(I,J)
  290    A(I,J)=ZERO
         A(I,K)=ONE
  300    CONTINUE
C          END.. SPECIAL FOR ZERO ROWS AND COLUMNS
      RETURN
  310 IERROR=5
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE UPDDON.  FOR SOLUTION NO. NDONE, VARI IS STORED IN
C      VDONE(NDONE).  HOWEVER, IF A MATCH BETWEEN SOLUTION NDONE AND A
C      PREVIOUSLY STORED SOLUTION, SAY K, IS FOUND, THEN VARI IS SET
C      TO VDONE(K), NDONE IS DECREMENTED, AND THE SOLUTION IS NOT
C      STORED.
C  IABS(LSDONE(NDONE,J,K)) ARE THE MIN. (K=1) AND THE MAX. (K=2) GRID
C      POINTS OF THE RANGE CONTAINING EXTREMUM J (THE EXTREMUM AT GRID
C      POINT LLSIGN(J+1)) FOR WHICH THE MONOTONICITY CONSTRAINTS ARE
C      BINDING.  THIS MEANS THAT THE SOLUTION IS EQUAL (I.E., FLAT)
C      FOR ALL POINTS IN THIS RANGE.  IF THE EXTREMUM IS AT  AN END
C      OF THE RANGE, THEN IN ORDER TO SAY A PRIORI THAT A NEW SET OF
C      EXTREMA WILL GIVE THE IDENTICAL SOLUTION (AND THUS ALLOW THE
C      ANALYSIS TO BE SKIPPED), ONE OF THE NEW EXTREMA MUST COINCIDE
C      WITH THIS EXTREMUM.  THIS IS SIGNIFIED BY APPENDING A MINUS
C      SIGN TO THE LSDONE(NDONE,J,K) THAT COINCIDES WITH THIS
C      EXTREMUM.  (OTHERWISE, IT IS ONLY NECESSARY THAT THE NEW
C      EXTREMUM LIE IN THE CLOSED INTERVAL
C      (LSDONE(NDONE,J,1),LSDONE(NDONE,J,2)).)
      SUBROUTINE UPDDON (
     1 NSGNM1,LLSIGN,LSDONE,MDONE,NDONE,NNQUSR,LBIND,MINEQ,
     2 NG,VARI,VDONE)
      LOGICAL LBIND, STORE
      DIMENSION LLSIGN(5), LSDONE(MDONE,3,2), LBIND(MINEQ),
     1 VDONE(MDONE)
      STORE=NSGNM1 .GE. 1
      IF (.NOT.STORE) GO TO 700
      VDONE(NDONE)=VARI
      DO 110 J=1,NSGNM1
        L=IABS(LLSIGN(J+1))
        KK=L-IABS(LLSIGN(J))-1
        LL=L+NNQUSR+1
        IF (KK .EQ. 0) GO TO 130
        DO 120 K=1,KK
          LL=LL-1
          IF (.NOT.LBIND(LL)) GO TO 130
  120   CONTINUE
        LL=LL-1
  130   LSDONE(NDONE,J,1)=MIN0(LL-NNQUSR+1,L)
        KK=IABS(LLSIGN(J+2))-L-1
        LL=NNQUSR-1+L
        IF (KK .EQ. 0) GO TO 150
        DO 140 K=1,KK
          LL=LL+1
          IF (.NOT.LBIND(LL)) GO TO 150
  140   CONTINUE
        LL=LL+1
  150   LSDONE(NDONE,J,2)=MAX0(LL-NNQUSR-1,L)
        IF (LSDONE(NDONE,J,1) .EQ. L) LSDONE(NDONE,J,1)=-L
        IF (LSDONE(NDONE,J,2) .EQ. L) LSDONE(NDONE,J,2)=-L
  110 CONTINUE
C-----------------------------------------------------------------------
C  CHECK TO SEE IF THIS IS IDENTICAL TO A PREVIOUSLY STORED SOLUTION.
C-----------------------------------------------------------------------
      IF (NDONE .LE. 1) GO TO 700
      KK=NDONE-1
      DO 210 K=1,KK
        DO 220 J=1,NSGNM1
          IF (IABS(LSDONE(NDONE,J,1)) .NE. IABS(LSDONE(K,J,1))  .OR.
     1    IABS(LSDONE(NDONE,J,2)) .NE. IABS(LSDONE(K,J,2))) GO TO 210
  220   CONTINUE
        VARI=VDONE(K)
        STORE=.FALSE.
        GO TO 700
  210 CONTINUE
  700 IF (.NOT.STORE) NDONE=NDONE-1
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE UPDLLS.  UPDATES LLSIGN (CURRENT POSITION OF EXTREMA),
C      LLSTRY, AND VARTRY.  CHECKS LLSIGN FOR OVERLAP OF EXTREMA, AND,
C      IF SO, BUMPS EXTREMA LYING TO THE RIGHT FARTHER TO THE RIGHT,
C      IF POSSIBLE.
C  LLSTRY(J,L) = POSITION OF EXTREMA GIVING THE SOLUTION WITH THE
C      LOWEST VARIANCE (VARTRY(L)) SO FAR AS THE POSITION OF
C      EXTREMUM L IS VARIED.  LLSTRY IS ALWAYS POSITIVE.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - ERRMES
C-----------------------------------------------------------------------
      SUBROUTINE UPDLLS (NSGNI,JSTAGE,NOUT,VARTRY,VARI,LLSTRY,
     1 LLSIGN,INC,DONE)
      LOGICAL DONE
      DIMENSION JSTAGE(NSGNI), VARTRY(NSGNI), LLSTRY(5,NSGNI),
     1 LLSIGN(5), INC(NSGNI)
      DIMENSION IHOLER(6)
      DATA IHOLER/1HU, 1HP, 1HD, 1HL, 1HL, 1HS/
      IF (NSGNI .LE. 1) GO TO 790
      NSGNP1=NSGNI+1
      DONE=.FALSE.
      L=NSGNP1
      DO 200 JLL=2,NSGNI
C-----------------------------------------------------------------------
C  L RUNS FROM NSGNI TO 2.
C-----------------------------------------------------------------------
        L=L-1
C-----------------------------------------------------------------------
C  JSTAGE(L) = 1,2, OR .GE.3 FOR INITIAL ANALYSIS, ANALYSIS WITH
C      EXTREMUM L MOVING RIGHT AND LOOKING FOR AN INCREASE IN VARI,
C      AND FOR THE FINAL STAGE WITH EXTREMUM L MOVING IN THE FINAL
C      DIRECTION AFTER AN INCREASE IN VARI IN ONE DIRECTION HAS
C      ALREADY BEEN FOUND, RESPECTIVELY.
C-----------------------------------------------------------------------
        JSTAGE(L)=JSTAGE(L)+1
        IF (JSTAGE(L) .LT. 1) CALL ERRMES (1,.TRUE.,IHOLER,NOUT)
        IF (JSTAGE(L)-2) 300,400,500
  300   IF (L .LT. NSGNI) GO TO 330
C-----------------------------------------------------------------------
C  INITIALIZE VARTRY AND LLSTRY WHEN JSTAGE(NSGNI)=1 (OR WHEN VARI
C      HAS DECREASED).
C-----------------------------------------------------------------------
        VARTRY(L)=VARI
        DO 310 J=1,NSGNP1
          LLSTRY(J,L)=IABS(LLSIGN(J))
  310   CONTINUE
        GO TO 350
C-----------------------------------------------------------------------
C  INITIALIZE VARTRY AND LLSTRY WHEN JSTAGE(L)=1 (OR WHEN VARI HAS
C      DECREASED) AND WHEN L.LT.NSGNI
C-----------------------------------------------------------------------
  330   VARTRY(L)=VARTRY(L+1)
        DO 340 J=1,NSGNP1
          LLSTRY(J,L)=LLSTRY(J,L+1)
  340   CONTINUE
C-----------------------------------------------------------------------
C  UPDATE LLSIGN, CHECK FOR OVERLAP OF EXTREMA, AND, IF SO, BUMP
C      THE EXTREMA WITH HIGHER L TO THE RIGHT, IF POSSIBLE.
C-----------------------------------------------------------------------
  350   DO 360 LL=2,NSGNI
          LLSIGN(LL)=ISIGN(LLSTRY(LL,L),LLSIGN(LL))
  360   CONTINUE
        LL=LLSTRY(L,L)+INC(L)
        LLSIGN(L)=ISIGN(LL,LLSIGN(L))
C
C  IF NO OVERLAP, THEN RETURN.
C
        IF (LL.GT.LLSTRY(L-1,L) .AND. LL.LT.LLSTRY(L+1,L)) GO TO 800
C
C  IF OVERLAP IS TO THE LEFT OR IF L=NSGNI, THEN INCREMENT JSTAGE(L).
C
        IF (LL.LE.LLSTRY(L-1,L) .OR. L.GE.NSGNI) GO TO 370
C
C  BUMP EXTREMUM L+1 TO THE RIGHT.
C
        LLSIGN(L+1)=ISIGN(LLSTRY(L+1,L)+1,LLSIGN(L+1))
        IF (IABS(LLSIGN(L+1)) .LT. LLSTRY(L+2,L)) GO TO 800
C
C  IF THERE ARE NO MORE EXTREMA TO THE RIGHT THAT CAN BUMPED, THEN
C      INCREMENT JSTAGE(L).
C
        IF (L+1 .GE. NSGNI) GO TO 370
C
C  BUMP EXTREMUM L+2 TO THE RIGHT.
C
        LLSIGN(L+2)=ISIGN(LLSTRY(L+2,L)+1,LLSIGN(L+2))
        IF (IABS(LLSIGN(L+2)) .LT. LLSTRY(L+3,L)) GO TO 800
C
C  OVERLAP COULD NOT BE REMEDIED BY BUMPING.  IF JSTAGE(L)=1, THEN
C      SET IT TO 2.  OTHERWISE, INCREMENT JSTAGE(L-1).
C
  370   IF (JSTAGE(L) .GT. 1) GO TO 510
        JSTAGE(L)=2
        GO TO 420
C-----------------------------------------------------------------------
C  TESTS WHEN JSTAGE(L)=2.
C-----------------------------------------------------------------------
C  IF VARI HAS DECREASED, THEN CONTINUE IN THE SAME DIRECTION
C      WITH JSTAGE(3)=3 THE NEXT ITERATION.
C
  400   IF (VARI-VARTRY(L)) 300,410,420
C
C  IF THE IDENTICAL VARIANCE HAS BEEN OBTAINED, THEN REPEAT
C      WITH JSTAGE(L)=2 AGAIN IN THE NEXT ITERATION.
C
  410   JSTAGE(L)=1
        GO TO 300
C
C  IF VARI HAS INCREASED, THEN TURN AROUND AND SEARCH TO THE LEFT
C      WITH JSTAGE(L)=3 IN THE NEXT ITERATION.
C
  420   INC(L)=-1
        GO TO 350
C-----------------------------------------------------------------------
C  TESTS WHEN JSTAGE(L)=3.
C-----------------------------------------------------------------------
C  IF VARI HAS NOT INCREASED, THEN CONTINUE WITH JSTAGE(L)=JSTAGE(L)+1
C      IN THE NEXT ITERATION.
C
  500   IF (VARI .LE. VARTRY(L)) GO TO 300
C
C  IF VARI HAS INCREASED, THEN INCREMENT JSTAGE(L-1) AND ZERO
C      JSTAGE(LL),LL=L,NSGNI.
C
  510   DO 520 LL=L,NSGNI
          JSTAGE(LL)=0
          INC(LL)=1
  520   CONTINUE
        VARI=VARTRY(L)
  200 CONTINUE
C-----------------------------------------------------------------------
C  PEAK-CONSTRAINED ANALYSIS IS DONE.  LOCAL MIN. HAS BEEN FOUND.
C-----------------------------------------------------------------------
  790 DONE=.TRUE.
  800 RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE UPDSGN.  UPDATES SIGNS OF A AND RHSNEQ (LEFT- AND
C      RIGHT-HAND SIDES OF EQ. (5.28)), AS WELL AS IISIGN(J)
C      (MONOTONICITY INDICATOR FOR J-TH GRID POINT) TO AGREE WITH
C       LLLSGN IN ANPEAK.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - ERRMES
C-----------------------------------------------------------------------
      SUBROUTINE UPDSGN (NNSGNI,LLLSGN,
     1 A,AINEQ,IISIGN,MA,MG,MINEQ,MREG,NGLE,NGLP1,NNINEQ,
     2 NNQUSR,NONNEG,NOUT,REG,RHSNEQ,S,VALPHA)
      DOUBLE PRECISION A, AINEQ, ONE, REG, RHSNEQ, S, VALPHA, ZERO
      LOGICAL NONNEG
      DIMENSION LLLSGN(5), A(MA,MG), REG(MREG,MG), S(MG,3),
     1 RHSNEQ(MINEQ), VALPHA(MG), IISIGN(MG), AINEQ(MINEQ,MG)
      DIMENSION IHOLER(6)
      DATA IHOLER/1HU, 1HP, 1HD, 1HS, 1HG, 1HN/
C     ZERO=0.E0!SP
      ZERO=0.D0
C     ONE=1.E0!SP
      ONE=1.D0
      IROW=NNQUSR
      IIROW=NNINEQ
      NNSGNP=NNSGNI+1
      DO 110 JS=1,NNSGNP
        LS=LLLSGN(JS)
        ICMIN=IABS(LS)
        IF (JS .LE. NNSGNI) GO TO 114
        IF (NONNEG .AND. LLLSGN(NNSGNI).GT.0) GO TO 116
        GO TO 110
  114   ICMAX=IABS(LLLSGN(JS+1))-1
        IF (ICMIN .GT. ICMAX) CALL ERRMES (1,.TRUE.,IHOLER,NOUT)
        IF (.NOT.NONNEG .OR. LS.GT.0) GO TO 130
C-----------------------------------------------------------------------
C  CONSTRAIN MINIMA TO BE NONNEGATIVE.
C-----------------------------------------------------------------------
  116   IIROW=IIROW+1
        IF (IIROW .GT. MINEQ) CALL ERRMES (2,.TRUE.,IHOLER,NOUT)
        DO 120 IICOL=1,NGLE
          A(IIROW,IICOL)=REG(ICMIN,IICOL)*S(IICOL,2)
  120   CONTINUE
        RHSNEQ(IIROW)=-VALPHA(ICMIN)
        DO 125 IICOL=1,NGLP1
          AINEQ(IIROW,IICOL)=ZERO
  125   CONTINUE
        AINEQ(IIROW,ICMIN)=ONE
        IF (JS. GT. NNSGNI) GO TO 110
C-----------------------------------------------------------------------
C  UPDATE SIGNS OF INCREASING OR DECREASING CONSTRAINTS.
C-----------------------------------------------------------------------
  130   DO 140 ICOL=ICMIN,ICMAX
          IROW=IROW+1
          IF (IROW .GT. NNINEQ) CALL ERRMES (3,.TRUE.,IHOLER,NOUT)
          IF (IISIGN(ICOL)*LS .GT. 0) GO TO 140
          IISIGN(ICOL)=-IISIGN(ICOL)
          DO 145 IICOL=1,NGLE
            A(IROW,IICOL)=-A(IROW,IICOL)
  145     CONTINUE
          RHSNEQ(IROW)=-RHSNEQ(IROW)
  140   CONTINUE
  110 CONTINUE
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE WRITIN.  WRITES OUT FINAL VALUES OF COMMON
C      VARIABLES (AFTER CHANGES DUE TO INPUT DATA AND USERIN), AS WELL
C      AS THE REST OF THE INPUT AND ANY SIMULATED DATA.
C-----------------------------------------------------------------------
C  CALLS SUBPROGRAMS - WRITYT
C-----------------------------------------------------------------------
      SUBROUTINE WRITIN (EXACT,G,LA,MG,MY,SQRTW,T,Y)
      DOUBLE PRECISION PRECIS, RANGE
      LOGICAL DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST, NEWPG1,
     1 NONNEG, ONLY1, PRWT, PRY, SIMULA, LUSER
      LOGICAL LEQUIV(11), LSPACE
      DIMENSION EXACT(MY), SQRTW(MY), T(MY), Y(MY), LA(6,50)
      DIMENSION IEQUIV(14), G(MG)
      COMMON /DBLOCK/ PRECIS, RANGE
      COMMON /SBLOCK/ DFMIN, SRMIN,
     1 ALPST(2), EXMAX, GMNMX(2), PLEVEL(2,2), RSVMNX(2,2), RUSER(100),
     2 SRANGE, YREF(4000),CK(504)
      COMMON /IBLOCK/ IGRID, IQUAD, IUNIT, IWT, LINEPG,
     1 MIOERR, MPKMOM, MQPITR, NEQ, NERFIT, NG, NINTT, NLINF, NORDER,
     2 IAPACK(6), ICRIT(2), IFORMT(70), IFORMW(70), IFORMY(70),
     3 IPLFIT(2), IPLRES(2), IPRINT(2), ITITLE(80), IUSER(50),
     4 IUSROU(2), LSIGN(4,4), MOMNMX(2), NENDZ(2), NFLAT(4,2), NGL,
     5 NGLP1, NIN, NINEQ, NNSGN(2), NOUT, NQPROG(2), NSGN(4), NY
      COMMON /LBLOCK/ DOCHOS, DOMOM, DOUSIN, DOUSNQ, LAST,
     1 NEWPG1, NONNEG, ONLY1, PRWT, PRY, SIMULA,
     2 LUSER(30)
      EQUIVALENCE (IGRID,IEQUIV(1)), (DOCHOS,LEQUIV(1))
      L=1
      IF (IWT.EQ.1 .OR. IWT.EQ.4) L=2
      LSPACE=MAX0(IUSROU(L),IPRINT(L)) .GE. 4
 5999 FORMAT (1H1)
      IF (LSPACE) WRITE(33,5999)
 5003 FORMAT (//1H )
      IF (.NOT.LSPACE) WRITE(33,5003)
 5100 FORMAT (40X,33HFINAL VALUES OF CONTROL VARIABLES)
      WRITE (33,5100)
 5110 FORMAT (1X,6A1,2H =,1P,10E12.5/(9X,10E12.5))
      WRITE (33,5110) (LA(K,1),K=1,6),DFMIN
      WRITE (33,5110) (LA(K,2),K=1,6),SRMIN
      WRITE (33,5110) (LA(K,3),K=1,6),ALPST
      WRITE (33,5110) (LA(K,4),K=1,6),GMNMX
      WRITE (33,5110) (LA(K,5),K=1,6),PLEVEL
      WRITE (33,5110) (LA(K,6),K=1,6),RSVMNX
      WRITE (33,5110) (LA(K,7),K=1,6),(RUSER(I),I=1,100)
      JJ=7
 5210 FORMAT (1X,6A1,2H =,10I12/(9X,10I12))
      DO 210 J=1,14
        JJ=JJ+1
        WRITE (33,5210) (LA(K,JJ),K=1,6),IEQUIV(J)
  210 CONTINUE
      WRITE (33,5210) (LA(K,22),K=1,6),ICRIT
 5220 FORMAT (1X,6A1,3H = ,80A1)
      WRITE (33,5220) (LA(K,23),K=1,6),IFORMT
      WRITE (33,5220) (LA(K,24),K=1,6),IFORMW
      WRITE (33,5220) (LA(K,25),K=1,6),IFORMY
      WRITE (33,5210) (LA(K,26),K=1,6),IPLFIT
      WRITE (33,5210) (LA(K,27),K=1,6),IPLRES
      WRITE (33,5210) (LA(K,28),K=1,6),IPRINT
      WRITE (33,5210) (LA(K,29),K=1,6),IUSER
      WRITE (33,5210) (LA(K,30),K=1,6),IUSROU
      WRITE (33,5210) (LA(K,31),K=1,6),LSIGN
      WRITE (33,5210) (LA(K,32),K=1,6),MOMNMX
      WRITE (33,5210) (LA(K,33),K=1,6),NENDZ
      WRITE (33,5210) (LA(K,34),K=1,6),NFLAT
      WRITE (33,5210) (LA(K,35),K=1,6),NNSGN
      WRITE (33,5210) (LA(K,36),K=1,6),NQPROG
      WRITE (33,5210) (LA(K,37),K=1,6),NSGN
      JJ=37
 5310 FORMAT (1X,6A1,2H =,10L12/(9X,10L12))
      DO 310 J=1,11
        JJ=JJ+1
        WRITE (33,5310) (LA(K,JJ),K=1,6),LEQUIV(J)
  310 CONTINUE
      WRITE (33,5310) (LA(K,49),K=1,6),LUSER
      IF (.NOT.SIMULA .AND. NY.LE.MY) CALL WRITYT (EXACT,
     1 G,IPRINT,IUSROU,IWT,MG,NOUT,NY,PRY,SIMULA,SQRTW,T,Y)
C5320 FORMAT (9H0PRECIS =,1PE9.2,10X,8HSRANGE =,E9.2,!SP
C    1 5X,7HRANGE =,E9.2)!SP
 5320 FORMAT (9H0PRECIS =,1PD9.2,10X,8HSRANGE =,E9.2,
     1 5X,7HRANGE =,D9.2)
      WRITE (33,5320) PRECIS, SRANGE, RANGE
      RETURN
      END
C++++++++++++++++ DOUBLE PRECISION VERSION 2DP (AUG 1982) ++++++++++++++
C  SUBROUTINE WRITYT.  IF PRY=.TRUE., THEN WRITYT WRITES Y (INPUT DATA),
C      T (INDEPENDENT
C      VARIABLE), AND, IF SIMULA=.TRUE., EXACT (EXACT SIMULATED DATA)
C      AND (Y-EXACT), AND, IF IWT=4, SQRTW (SQUARE ROOTS OF WEIGHTS).
      SUBROUTINE WRITYT (EXACT,G,IPRINT,IUSROU,IWT,MG,NOUT,NY,
     1 PRY,SIMULA,SQRTW,T,Y)
      LOGICAL PRY, SIMULA, LSPACE
      DIMENSION EXACT(NY), SQRTW(NY), T(NY), Y(NY), G(MG),
     1 IPRINT(2), IUSROU(2)
      IF (.NOT.PRY) GO TO 700
      L=1
      IF (IWT.EQ.1 .OR. IWT.EQ.4) L=2
      LSPACE=MAX0(IUSROU(L),IPRINT(L)) .GE. 4
 5999 FORMAT (1H1)
      IF (LSPACE) WRITE (33,5999)
 5003 FORMAT (//1X)
      IF (.NOT.LSPACE) WRITE(33,5003)
      IF (SIMULA) GO TO 200
 5110 FORMAT (5(12X,1HT,12X,1HY)/(2X,1PE11.3,E13.5,E13.3,E13.5,
     1 E13.3,E13.5,E13.3,E13.5,E13.3,E13.5))
      IF (IWT .NE. 4) WRITE (33,5110) (T(J),Y(J),J=1,NY)
 5120 FORMAT (3(17X,1HT,12X,1HY,8X,5HSQRTW)/(5X,1P,3E13.5,5X,3E13.5,
     1 5X,3E13.5))
      IF (IWT .EQ. 4) WRITE (33,5120) (T(J),Y(J),SQRTW(J),J=1,NY)
      GO TO 700
 5210 FORMAT (2(17X,1HT,12X,1HY,8X,5HEXACT,8X,5HERROR))
  200 IF (IWT .NE. 4) WRITE (33,5210)
 5211 FORMAT (2(12X,1HT,12X,1HY,8X,5HEXACT,8X,5HERROR,8X,
     1 5HSQRTW))
      IF (IWT .EQ. 4) WRITE (33,5211)
      DO 210 J=2,NY,2
        DUM=Y(J-1)-EXACT(J-1)
        DDUM=Y(J)-EXACT(J)
 5220   FORMAT (5X,1P,4E13.5,5X,4E13.5)
        IF (IWT .NE. 4) WRITE (33,5220) T(J-1),Y(J-1),EXACT(J-1),DUM,
     1  T(J),Y(J),EXACT(J),DDUM
 5221   FORMAT (2X,1PE11.3,4E13.5,E13.3,4E13.5)
        IF (IWT .EQ. 4) WRITE (33,5221) T(J-1),Y(J-1),EXACT(J-1),DUM,
     1  SQRTW(J-1),T(J),Y(J),EXACT(J),DDUM,SQRTW(J)
  210 CONTINUE
      IF (MOD(NY,2) .EQ. 0) GO TO 700
      DUM=Y(NY)-EXACT(NY)
      IF (IWT .NE. 4) WRITE (33,5220) T(NY),Y(NY),EXACT(NY),DUM
      IF (IWT .EQ. 4) WRITE (33,5221) T(NY),Y(NY),EXACT(NY),DUM,
     1 SQRTW(NY)
  700 RETURN
      END

